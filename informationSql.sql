/*
Date: 2019-09-17 18:36:12
*/

CREATE DATABASE `telecom_information` DEFAULT CHARACTER SET utf8;

USE `telecom_information`;

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for user
-- ----------------------------
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `username` varchar(64) DEFAULT NULL,
  `nickname` varchar(64) DEFAULT NULL,
  `password` varchar(255) DEFAULT NULL,
  `enabled` tinyint(1) DEFAULT '1',
  `email` varchar(64) DEFAULT NULL, 
  `phone` int(30) not null,
--   `roleId` int(100) not null,
  `departmentId` int(100) not null,
--   `regTime` datetime DEFAULT NULL,
--   PRIMARY KEY (`id`)
--   KEY `departmentId` (`departmentId`),

--   CONSTRAINT `user_ibfk_1` FOREIGN KEY (`departmentId`) REFERENCES `department` (`id`)

) ENGINE=InnoDB AUTO_INCREMENT=1010 DEFAULT CHARSET=utf8;
-- ----------------------------
-- Records of user
-- ----------------------------
INSERT INTO `user` VALUES ('1000', 'admin','管理员','202cb962ac59075b964b07152d234b70', '1', 'linghu@qq.com','12345','2017-12-08 09:30:22',1);
INSERT INTO `user` VALUES ('1001', 'pyy', '彭于晏','202cb962ac59075b964b07152d234b70', '1', 'pyy@qq.com',  '12345','2017-12-08 09:30:22',4);
INSERT INTO `user` VALUES ('1002', 'qf', '乔峰','202cb962ac59075b964b07152d234b70', '1', 'qiaofeng@qq.com', '12345','2017-12-08 09:30:22',5);
INSERT INTO `user` VALUES ('1003', 'dzc', '电子厂','123', '0', 'duanzhengchun@qq.com',  '12345',8);
INSERT INTO `user` VALUES ('1004', 'fqy', '风清扬','123', '1', 'fqy@qq.com','12345',91);
INSERT INTO `user` VALUES ('1005', 'sds', '所得税','123', '1', 'sds@qq.com',  '12345',92);
INSERT INTO `user` VALUES ('1006', 'zsf', '张三丰','123', '1', 'zsf@qq.com', '12345',81);
INSERT INTO `user` VALUES ('1007', 'my', '马云','123', '0', 'my@qq.com',  '12345',82);
INSERT INTO `user` VALUES ('1008', 'mht', '马化腾','123', '1', 'mht@qq.com', '12345',85);
INSERT INTO `user` VALUES ('1009', 'wjl', '王健林','123', '0', 'wjl@qq.com',  '12345','2017-12-08 09:30:22',86);

-- ----------------------------
-- Table structure for department
-- ----------------------------
-- DROP TABLE IF EXISTS `department`;
-- CREATE TABLE `department` (
--   `id` int(11) NOT NULL AUTO_INCREMENT,
--   `deptName` varchar(32) DEFAULT NULL COMMENT '部门名称',
--   `parentId` int(11) DEFAULT NULL,
--   `depPath` varchar(255) DEFAULT NULL,
--   `enabled` tinyint(1) DEFAULT '1',
--   `isParent` tinyint(1) DEFAULT '0',
--   PRIMARY KEY (`id`)
-- --     KEY `branchId` (`branchId`),
-- --   CONSTRAINT `department_ibfk_1` FOREIGN KEY (`branchId`) REFERENCES `branch` (`id`)
-- ) ENGINE=InnoDB AUTO_INCREMENT=100 DEFAULT CHARSET=utf8;
-- -- ----------------------------
-- -- Records of department
-- -- ----------------------------
-- INSERT INTO `department` VALUES ('1', '股东会', '-1', '.1', '1', '1');
-- INSERT INTO `department` VALUES ('4', '董事会', '1', '.1.4', '1', '1');
-- INSERT INTO `department` VALUES ('5', '总办', '4', '.1.4.5', '1', '1');
-- INSERT INTO `department` VALUES ('8', '财务部', '5', '.1.4.5.8', '1', '0');
-- INSERT INTO `department` VALUES ('78', '市场部', '5', '.1.4.5.78', '1', '0');
-- INSERT INTO `department` VALUES ('91', '企信部', '5', '.1.4.5.91', '0','1');
-- INSERT INTO `department` VALUES ('92', '网络部', '5', '.1.4.5.92', '0','1');
-- INSERT INTO `department` VALUES ('81', '滨江分局', '5', '.1.4.5.81', '1', '1');
-- INSERT INTO `department` VALUES ('82', '滨江分局市场部', '81', '.1.4.5.81.82', '1', '0');
-- INSERT INTO `department` VALUES ('85', '滨江分局政企客户部', '81', '.1.4.5.81.85', '1', '0');
-- INSERT INTO `department` VALUES ('86', '滨江分局行客中心', '81', '.1.4.5.81.86', '1', '0');
-- INSERT INTO `department` VALUES ('87', '滨江分局校园中心', '81', '.1.4.5.81.87', '1', '0');
-- INSERT INTO `department` VALUES ('88', '滨江分局渠道中心', '81', '.1.4.5.81.87', '1', '0');


-- ----------------------------
-- Table structure for roles
-- ----------------------------
DROP TABLE IF EXISTS `roles`;
CREATE TABLE `roles` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(64) DEFAULT NULL,
--   `nameZh` varchar(64) DEFAULT NULL COMMENT '角色名称',
--   `parentRole` int(20) not null ,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=15 DEFAULT CHARSET=utf8;
-- ----------------------------
-- Records of role
-- ----------------------------
INSERT INTO `roles` VALUES ('1','超级管理员');
INSERT INTO `roles` VALUES ('2','滨江区综合部经理');
INSERT INTO `roles` VALUES ('3', '滨江区政企客户部经理');
INSERT INTO `roles` VALUES ('4', '滨江区市场部副经理');
INSERT INTO `roles` VALUES ('5','滨江区市场部渠道经理');
INSERT INTO `roles` VALUES ('6', '滨江区政企客户部副经理');
INSERT INTO `roles` VALUES ('7',  '滨江区政企支撑部经理');
INSERT INTO `roles` VALUES ('8', '滨江区政企支撑部副经理');
INSERT INTO `roles` VALUES ('9', '系统管理员');
INSERT INTO `roles` VALUES ('10','滨江区市场部经理');
-- ----------------------------
-- Table structure for roles_user
-- ----------------------------
DROP TABLE IF EXISTS `roles_user`;
CREATE TABLE `roles_user` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `rId` int(50) DEFAULT NULL COMMENT '角色id',
  `uId` int(250) not null,
--   `parentRole` int(20) not null ,
  PRIMARY KEY (`id`),
  KEY `uId` (`uId`),
  KEY `rId` (`rId`),
  CONSTRAINT `roles_user_ibfk_1` FOREIGN KEY (`uId`) REFERENCES `user` (`id`),
  CONSTRAINT `roles_user_ibfk_2` FOREIGN KEY (`rId`) REFERENCES `roles` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=131 DEFAULT CHARSET=utf8;
-- ----------------------------
-- Records of user_role
-- ----------------------------
INSERT INTO `roles_user` VALUES ('120', '1', '1000');
INSERT INTO `roles_user` VALUES ('130', '2', '1000');
INSERT INTO `roles_user` VALUES ('121', '2', '1001');
INSERT INTO `roles_user` VALUES ('122', '3', '1002');
INSERT INTO `roles_user` VALUES ('123', '4', '1003');
INSERT INTO `roles_user` VALUES ('124', '5', '1004');
INSERT INTO `roles_user` VALUES ('125', '6', '1005');
INSERT INTO `roles_user` VALUES ('126', '7', '1006');
INSERT INTO `roles_user` VALUES ('127', '8', '1007');
INSERT INTO `roles_user` VALUES ('128', '9', '1008');
INSERT INTO `roles_user` VALUES ('129', '10', '1009');

-- ----------------------------
-- Table structure for information
-- ----------------------------
DROP TABLE IF EXISTS `information`;
CREATE TABLE `information` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `company` varchar(30) not null COMMENT '哪个公司',
  `source` varchar(10) DEFAULT NULL COMMENT 'id',
   `title` varchar(10) DEFAULT NULL COMMENT '标题',
  `product` varchar(50) not null COMMENT '产品' ,
  `summary` text COMMENT '简述',
  `mdContent` text COMMENT 'md文件源码',
  `htmlContent` text COMMENT 'html源码',
 --   `effectDate` date not null,
--    `endDate` date not null,
  `publishDate` datetime DEFAULT NULL,
  `editTime` datetime DEFAULT NULL,
  -- `inforContent` text, 
  `alarm` varchar(20) not null ,
  `remark` varchar(255) default null,
  `state` int(11) DEFAULT NULL COMMENT '1表示已发表，2表示已删除',
  `pageView` int(11) DEFAULT '0',
  `cid` int(11) DEFAULT NULL,
  `uid` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `uid` (`uid`),
  KEY `cid` (`cid`),
  CONSTRAINT `information_ibfk_1` FOREIGN KEY (`uid`) REFERENCES `user` (`id`),
  CONSTRAINT `information_ibfk_2` FOREIGN KEY (`cid`) REFERENCES `category` (`id`)
) ENGINE=InnoDB  DEFAULT CHARSET=utf8;
-- ----------------------------
-- Records of information
-- ----------------------------
INSERT INTO `information` VALUES ('1','移动',  '社区','国庆套餐','移动','summary199套餐40g流量1000分钟电话无限短信','年初的时候，写过两篇博客介绍在Spring Boot中如何使用WebSocket发送消息【[在Spring Boot框架下使用WebSocket实现消息推送](http://blog.csdn.net/u012702547/article/details/53816326)】【[在Spring Boot框架下使用WebSocket实现聊天功能](http://blog.csdn.net/u012702547/article/details/53835453)】，最近看到很多小伙伴对WebSocket的讨论还比较火热，so，打算写几篇文章来系统的介绍下websocket。OK，废话不多说，下面开始我们的正文。\n\n---\n# 为什么要有WebSocket这个技术\n\n大家都知道，HTML页面在刚刚开始出现的时候是静态的，不能够进行交互，后来有了JavaScript，在一定程度上解决了这个问题，但是JavaScript刚出现的时候并不能和服务端进行交互，直到Ajax的出现。Ajax有效的解决了页面和服务端进行交互的问题，不过Ajax有一个问题，就是所有的请求都必须由客户端发起，服务端进行响应，如果服务端有最新的消息，难以即时的发送到客户端去，在WebSocket技术出现之前，为了让客户端能够即时的获取服务端的数据，一般采用如下三种方案：\n## 轮询\n这是最简单的一种解决方案， 就是客户端在固定的时间间隔下（一般是1秒）不停的向服务器端发送请求，查看服务端是否有最新的数据，服务端如果有最新的数据则返回给客户端，服务端如果没有则返回一个空的json或者xml文档，这种方式的实现起来简单，但是弊端也很明显，就是会有大量的无效请求，服务端的资源被大大的浪费了。\n## 长连接\n长连接有点类似于轮询，不同的是服务端不是每次都会响应客户端的请求，只有在服务端有最新数据的时候才会响应客户端的请求，这种方式很明显会节省网络资源和服务端资源，但是也存在一些问题，比如：\n>1.如果浏览器在服务器响应之前有新数据要发送就只能创建一个新的并发请求，或者先尝试断掉当前请求然后再创建新的请求。  \n>2.TCP和HTTP规范中都有连接超时一说，所以所谓的长连接并不能一直持续，服务端和客户端的连接需要定期的连接和关闭再连接，当然也有一些技术能够延长每次连接的时间，这是题外话。  \n\n## Applet和Flash\nApplet和Flash都已经是明日黄花了，不过这两个技术在当年除了可以让我们的HTML页面更加绚丽之外，还可以解决消息推送问题。在Ajax这种技术去实现全双工通信已经陷入困境的时候，开发者试图用Applet和Flash来模拟全双工通信，开发者可以创建一个只有1个像素点大小的普通透明的Applet或者Flash，然后将之内嵌在页面中， 然后这个Applet或者Flash中的代码创建出一个Socket连接，这种连接方式消除了HTTP协议中的各种限制，当服务器有消息发送到客户端的时候，开发者可以在Applet或者Flash中调用JavaScript函数，并将服务器传来的消息传递给JavaScript函数，然后更新页面，当浏览器有数据要发送给服务器的时候，也一样，通过Applet或者Flash来传递。这种方式真正的实现了全双工通信，不过也有问题，如下：\n>1.浏览器必须能够运行Java或者Flash  \n>2.无论是Applet还是Flash都存在安全问题  \n>3.随着HTML5在标准在浏览器中广泛支持，Flash下架已经被提上日程([\n终于要放弃，Adobe宣布2020年正式停止支持Flash](http://tech.163.com/17/0726/07/CQ8M4HT200097U7T.html))  \n\n# WebSocket有哪些特点\n\n既然上面这些技术都不行，那么谁行？当然是我WebSocket了！\n\n## HTTP/1.1的升级特性\n要说WebSocket协议，我们得先来说说HTTP协议的一个请求头，事实上，所有的HTTP客户端（浏览器、移动端等）都可以在请求头中包含Connection:Upgrade，这个表示客户端希望升级请求协议，那么希望升级成什么样的协议呢？我们需要在Upgrade头中指定一个或者多个协议的列表，当然这些协议必须兼容HTTP/1.1协议。服务器收到请求之后，如果接受升级请求，那么将会返回一个101的状态码，表示转换请求协议，同时在响应的Upgrade头中使用单个值，这个单个值就是请求协议列表中服务器支持的第一个协议（即请求头的Upgrade字段中列出来的协议列表中服务器支持的第一个协议）。  \nHTTP升级最大的好处是最终使我们可以使用任意的协议，在升级握手完成之后，它就不再使用HTTP连接了，我们甚至可以在升级握手完成之后建立一个Socket连接，理论上我们可以使用HTTP升级在两个端点之间使用任何自己设计的协议，进而创建出各种各样的TCP通信，当然浏览器不会让开发者随意去这么做，而是要指定某些协议，WebSocket应运而生！\n我们来看一个截图：  \n![这里写图片描述](http://img.blog.csdn.net/20170827204229481?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjcwMjU0Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n## 使用HTTP/1.1升级的WebSocket协议\nOK，了解了HTTP/1.1协议的升级特性之后，我们再来详细看看整个过程是怎么样的？  \n一个WebSocket请求首先使用非正常的HTTP请求以特定的模式访问一个URL，这个URL有两种模式，分别是ws和wss，对应HTTP协议中的http和https，请求头中除了Connection:Upgrade之外还有一个Upgrade:websocket,它们两个将共同告诉服务器将连接升级为WebSocket这样一种全双工协议。如此，在握手完成之后，文本消息或者其他二进制消息就可以同时在两个方向上进行发送，而不需要关闭和重建连接。此时的客户端和服务端关系其实是对等的，他们都可以互相向对方主动发消息。那么这里有一点需要注意：那就是ws和wss模式并不能算作HTTP协议的一部分，因为HTTP请求和请求头并不包含URL模式，HTTP请求只在请求的第一行中包含相对于服务器的URL，在Host头中包含域名，而WebSocket中特有的ws和wss模式主要用于通知浏览器和API是希望使用SSL/TLS(wss)，还是希望使用不加密的方式(ws)进行连接。\n## WebSocket协议的优势\n说了这么多，那么接下来我们来看看WebSocket协议都有哪些优势：\n>1.由于WebSocket连接在端口80(ws)或者443(wss)上创建，与HTTP使用的端口相同，这样，基本上所有的防火墙都不会阻塞WebSocket连接  \n\n>2.WebSocket使用HTTP协议进行握手，因此它可以自然而然的集成到网络浏览器和HTTP服务器中  \n\n>3.心跳消息(ping和pong)将被反复的发送，进而保持WebSocket连接几乎一直处于活跃状态。一般来说是这样，一个节点周期性的发送一个小数据包到另外一个节点(ping)，而另一个节点则使用了包含了相同数据的数据包作为响应(pong),这样两个节点都将处于连接状态  \n\n>4.使用该协议，当消息启动或者到达的时候，服务端和客户端都可以知道  \n\n>5.WebSocket连接关闭时将发送一个特殊的关闭消息  \n\n>6.WebSocket支持跨域，可以避免Ajax的限制  \n\n>7.HTTP规范要求浏览器将并发连接数限制为每个主机名两个连接，但是当我们使用WebSocket的时候，当握手完成之后该限制就不存在了，因为此时的连接已经不再是HTTP连接了  \n## WebSocket协议的用途\n\n说了这么多那么WebSocket协议到底可以用在哪些地方呢？事实上，WebSocket协议的用途几乎是没有限制的，比如：\n\n>1.网页上的在线聊天   \n\n>2.多人在线游戏   \n\n>3.在线股票网站   \n\n>4.在线即时新闻网站   \n\n>5.高清视频流   \n\n>6.应用集群之间的通信  \n\n>7.远程系统/软件的状态和性能的实时监控 \n\n\n# 结语  \n\n说了这么多，可能很多小伙伴觉得这个WebSocket貌似用起来很麻烦，其实不麻烦，所有的东西都有对应的API来帮助我们实现，<big>**小伙伴们稍安勿躁，我们将在下篇文章中来介绍WebSocket的实战应用。**</big>\n\n参考资料：《JavaEE 编程》\n\n更多JavaEE资料请关注公众号  \n![这里写图片描述](http://img.blog.csdn.net/20170827204306560?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjcwMjU0Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n以上。\n', '<p>年初的时候，写过两篇博客介绍在Spring Boot中如何使用WebSocket发送消息【<a href=\"http://blog.csdn.net/u012702547/article/details/53816326\" target=\"_blank\">在Spring Boot框架下使用WebSocket实现消息推送</a>】【<a href=\"http://blog.csdn.net/u012702547/article/details/53835453\" target=\"_blank\">在Spring Boot框架下使用WebSocket实现聊天功能</a>】，最近看到很多小伙伴对WebSocket的讨论还比较火热，so，打算写几篇文章来系统的介绍下websocket。OK，废话不多说，下面开始我们的正文。</p>\n<hr />\n<h1>为什么要有WebSocket这个技术</h1>\n<p>大家都知道，HTML页面在刚刚开始出现的时候是静态的，不能够进行交互，后来有了JavaScript，在一定程度上解决了这个问题，但是JavaScript刚出现的时候并不能和服务端进行交互，直到Ajax的出现。Ajax有效的解决了页面和服务端进行交互的问题，不过Ajax有一个问题，就是所有的请求都必须由客户端发起，服务端进行响应，如果服务端有最新的消息，难以即时的发送到客户端去，在WebSocket技术出现之前，为了让客户端能够即时的获取服务端的数据，一般采用如下三种方案：</p>\n<h2>轮询</h2>\n<p>这是最简单的一种解决方案， 就是客户端在固定的时间间隔下（一般是1秒）不停的向服务器端发送请求，查看服务端是否有最新的数据，服务端如果有最新的数据则返回给客户端，服务端如果没有则返回一个空的json或者xml文档，这种方式的实现起来简单，但是弊端也很明显，就是会有大量的无效请求，服务端的资源被大大的浪费了。</p>\n<h2>长连接</h2>\n<p>长连接有点类似于轮询，不同的是服务端不是每次都会响应客户端的请求，只有在服务端有最新数据的时候才会响应客户端的请求，这种方式很明显会节省网络资源和服务端资源，但是也存在一些问题，比如：</p>\n<blockquote>\n<p>1.如果浏览器在服务器响应之前有新数据要发送就只能创建一个新的并发请求，或者先尝试断掉当前请求然后再创建新的请求。<br />\n2.TCP和HTTP规范中都有连接超时一说，所以所谓的长连接并不能一直持续，服务端和客户端的连接需要定期的连接和关闭再连接，当然也有一些技术能够延长每次连接的时间，这是题外话。</p>\n</blockquote>\n<h2>Applet和Flash</h2>\n<p>Applet和Flash都已经是明日黄花了，不过这两个技术在当年除了可以让我们的HTML页面更加绚丽之外，还可以解决消息推送问题。在Ajax这种技术去实现全双工通信已经陷入困境的时候，开发者试图用Applet和Flash来模拟全双工通信，开发者可以创建一个只有1个像素点大小的普通透明的Applet或者Flash，然后将之内嵌在页面中， 然后这个Applet或者Flash中的代码创建出一个Socket连接，这种连接方式消除了HTTP协议中的各种限制，当服务器有消息发送到客户端的时候，开发者可以在Applet或者Flash中调用JavaScript函数，并将服务器传来的消息传递给JavaScript函数，然后更新页面，当浏览器有数据要发送给服务器的时候，也一样，通过Applet或者Flash来传递。这种方式真正的实现了全双工通信，不过也有问题，如下：</p>\n<blockquote>\n<p>1.浏览器必须能够运行Java或者Flash<br />\n2.无论是Applet还是Flash都存在安全问题<br />\n3.随着HTML5在标准在浏览器中广泛支持，Flash下架已经被提上日程(<a href=\"http://tech.163.com/17/0726/07/CQ8M4HT200097U7T.html\" target=\"_blank\"><br />\n终于要放弃，Adobe宣布2020年正式停止支持Flash</a>)</p>\n</blockquote>\n<h1>WebSocket有哪些特点</h1>\n<p>既然上面这些技术都不行，那么谁行？当然是我WebSocket了！</p>\n<h2>HTTP/1.1的升级特性</h2>\n<p>要说WebSocket协议，我们得先来说说HTTP协议的一个请求头，事实上，所有的HTTP客户端（浏览器、移动端等）都可以在请求头中包含Connection:Upgrade，这个表示客户端希望升级请求协议，那么希望升级成什么样的协议呢？我们需要在Upgrade头中指定一个或者多个协议的列表，当然这些协议必须兼容HTTP/1.1协议。服务器收到请求之后，如果接受升级请求，那么将会返回一个101的状态码，表示转换请求协议，同时在响应的Upgrade头中使用单个值，这个单个值就是请求协议列表中服务器支持的第一个协议（即请求头的Upgrade字段中列出来的协议列表中服务器支持的第一个协议）。<br />\nHTTP升级最大的好处是最终使我们可以使用任意的协议，在升级握手完成之后，它就不再使用HTTP连接了，我们甚至可以在升级握手完成之后建立一个Socket连接，理论上我们可以使用HTTP升级在两个端点之间使用任何自己设计的协议，进而创建出各种各样的TCP通信，当然浏览器不会让开发者随意去这么做，而是要指定某些协议，WebSocket应运而生！<br />\n我们来看一个截图：<br />\n<img src=\"http://img.blog.csdn.net/20170827204229481?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjcwMjU0Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" /></p>\n<h2>使用HTTP/1.1升级的WebSocket协议</h2>\n<p>OK，了解了HTTP/1.1协议的升级特性之后，我们再来详细看看整个过程是怎么样的？<br />\n一个WebSocket请求首先使用非正常的HTTP请求以特定的模式访问一个URL，这个URL有两种模式，分别是ws和wss，对应HTTP协议中的http和https，请求头中除了Connection:Upgrade之外还有一个Upgrade:websocket,它们两个将共同告诉服务器将连接升级为WebSocket这样一种全双工协议。如此，在握手完成之后，文本消息或者其他二进制消息就可以同时在两个方向上进行发送，而不需要关闭和重建连接。此时的客户端和服务端关系其实是对等的，他们都可以互相向对方主动发消息。那么这里有一点需要注意：那就是ws和wss模式并不能算作HTTP协议的一部分，因为HTTP请求和请求头并不包含URL模式，HTTP请求只在请求的第一行中包含相对于服务器的URL，在Host头中包含域名，而WebSocket中特有的ws和wss模式主要用于通知浏览器和API是希望使用SSL/TLS(wss)，还是希望使用不加密的方式(ws)进行连接。</p>\n<h2>WebSocket协议的优势</h2>\n<p>说了这么多，那么接下来我们来看看WebSocket协议都有哪些优势：</p>\n<blockquote>\n<p>1.由于WebSocket连接在端口80(ws)或者443(wss)上创建，与HTTP使用的端口相同，这样，基本上所有的防火墙都不会阻塞WebSocket连接</p>\n</blockquote>\n<blockquote>\n<p>2.WebSocket使用HTTP协议进行握手，因此它可以自然而然的集成到网络浏览器和HTTP服务器中</p>\n</blockquote>\n<blockquote>\n<p>3.心跳消息(ping和pong)将被反复的发送，进而保持WebSocket连接几乎一直处于活跃状态。一般来说是这样，一个节点周期性的发送一个小数据包到另外一个节点(ping)，而另一个节点则使用了包含了相同数据的数据包作为响应(pong),这样两个节点都将处于连接状态</p>\n</blockquote>\n<blockquote>\n<p>4.使用该协议，当消息启动或者到达的时候，服务端和客户端都可以知道</p>\n</blockquote>\n<blockquote>\n<p>5.WebSocket连接关闭时将发送一个特殊的关闭消息</p>\n</blockquote>\n<blockquote>\n<p>6.WebSocket支持跨域，可以避免Ajax的限制</p>\n</blockquote>\n<blockquote>\n<p>7.HTTP规范要求浏览器将并发连接数限制为每个主机名两个连接，但是当我们使用WebSocket的时候，当握手完成之后该限制就不存在了，因为此时的连接已经不再是HTTP连接了</p>\n</blockquote>\n<h2>WebSocket协议的用途</h2>\n<p>说了这么多那么WebSocket协议到底可以用在哪些地方呢？事实上，WebSocket协议的用途几乎是没有限制的，比如：</p>\n<blockquote>\n<p>1.网页上的在线聊天</p>\n</blockquote>\n<blockquote>\n<p>2.多人在线游戏</p>\n</blockquote>\n<blockquote>\n<p>3.在线股票网站</p>\n</blockquote>\n<blockquote>\n<p>4.在线即时新闻网站</p>\n</blockquote>\n<blockquote>\n<p>5.高清视频流</p>\n</blockquote>\n<blockquote>\n<p>6.应用集群之间的通信</p>\n</blockquote>\n<blockquote>\n<p>7.远程系统/软件的状态和性能的实时监控</p>\n</blockquote>\n<h1>结语</h1>\n<p>说了这么多，可能很多小伙伴觉得这个WebSocket貌似用起来很麻烦，其实不麻烦，所有的东西都有对应的API来帮助我们实现，<big><strong>小伙伴们稍安勿躁，我们将在下篇文章中来介绍WebSocket的实战应用。</strong></big></p>\n<p>参考资料：《JavaEE 编程》</p>\n<p>更多JavaEE资料请关注公众号<br />\n<img src=\"http://img.blog.csdn.net/20170827204306560?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjcwMjU0Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" /></p>\n<p>以上。</p>\n', '2017-12-21 22:33:31', '2017-12-21 22:33:31','紧急','这是备注','1','20',4,1);
INSERT INTO `information` VALUES ('2','联通', '营业厅','元旦活动','宽带','summary2199套餐送半年宽带','年初的时候，写过两篇博客介绍在Spring Boot中如何使用WebSocket发送消息【[在Spring Boot框架下使用WebSocket实现消息推送](http://blog.csdn.net/u012702547/article/details/53816326)】【[在Spring Boot框架下使用WebSocket实现聊天功能](http://blog.csdn.net/u012702547/article/details/53835453)】，最近看到很多小伙伴对WebSocket的讨论还比较火热，so，打算写几篇文章来系统的介绍下websocket。OK，废话不多说，下面开始我们的正文。\n\n---\n# 为什么要有WebSocket这个技术\n\n大家都知道，HTML页面在刚刚开始出现的时候是静态的，不能够进行交互，后来有了JavaScript，在一定程度上解决了这个问题，但是JavaScript刚出现的时候并不能和服务端进行交互，直到Ajax的出现。Ajax有效的解决了页面和服务端进行交互的问题，不过Ajax有一个问题，就是所有的请求都必须由客户端发起，服务端进行响应，如果服务端有最新的消息，难以即时的发送到客户端去，在WebSocket技术出现之前，为了让客户端能够即时的获取服务端的数据，一般采用如下三种方案：\n## 轮询\n这是最简单的一种解决方案， 就是客户端在固定的时间间隔下（一般是1秒）不停的向服务器端发送请求，查看服务端是否有最新的数据，服务端如果有最新的数据则返回给客户端，服务端如果没有则返回一个空的json或者xml文档，这种方式的实现起来简单，但是弊端也很明显，就是会有大量的无效请求，服务端的资源被大大的浪费了。\n## 长连接\n长连接有点类似于轮询，不同的是服务端不是每次都会响应客户端的请求，只有在服务端有最新数据的时候才会响应客户端的请求，这种方式很明显会节省网络资源和服务端资源，但是也存在一些问题，比如：\n>1.如果浏览器在服务器响应之前有新数据要发送就只能创建一个新的并发请求，或者先尝试断掉当前请求然后再创建新的请求。  \n>2.TCP和HTTP规范中都有连接超时一说，所以所谓的长连接并不能一直持续，服务端和客户端的连接需要定期的连接和关闭再连接，当然也有一些技术能够延长每次连接的时间，这是题外话。  \n\n## Applet和Flash\nApplet和Flash都已经是明日黄花了，不过这两个技术在当年除了可以让我们的HTML页面更加绚丽之外，还可以解决消息推送问题。在Ajax这种技术去实现全双工通信已经陷入困境的时候，开发者试图用Applet和Flash来模拟全双工通信，开发者可以创建一个只有1个像素点大小的普通透明的Applet或者Flash，然后将之内嵌在页面中， 然后这个Applet或者Flash中的代码创建出一个Socket连接，这种连接方式消除了HTTP协议中的各种限制，当服务器有消息发送到客户端的时候，开发者可以在Applet或者Flash中调用JavaScript函数，并将服务器传来的消息传递给JavaScript函数，然后更新页面，当浏览器有数据要发送给服务器的时候，也一样，通过Applet或者Flash来传递。这种方式真正的实现了全双工通信，不过也有问题，如下：\n>1.浏览器必须能够运行Java或者Flash  \n>2.无论是Applet还是Flash都存在安全问题  \n>3.随着HTML5在标准在浏览器中广泛支持，Flash下架已经被提上日程([\n终于要放弃，Adobe宣布2020年正式停止支持Flash](http://tech.163.com/17/0726/07/CQ8M4HT200097U7T.html))  \n\n# WebSocket有哪些特点\n\n既然上面这些技术都不行，那么谁行？当然是我WebSocket了！\n\n## HTTP/1.1的升级特性\n要说WebSocket协议，我们得先来说说HTTP协议的一个请求头，事实上，所有的HTTP客户端（浏览器、移动端等）都可以在请求头中包含Connection:Upgrade，这个表示客户端希望升级请求协议，那么希望升级成什么样的协议呢？我们需要在Upgrade头中指定一个或者多个协议的列表，当然这些协议必须兼容HTTP/1.1协议。服务器收到请求之后，如果接受升级请求，那么将会返回一个101的状态码，表示转换请求协议，同时在响应的Upgrade头中使用单个值，这个单个值就是请求协议列表中服务器支持的第一个协议（即请求头的Upgrade字段中列出来的协议列表中服务器支持的第一个协议）。  \nHTTP升级最大的好处是最终使我们可以使用任意的协议，在升级握手完成之后，它就不再使用HTTP连接了，我们甚至可以在升级握手完成之后建立一个Socket连接，理论上我们可以使用HTTP升级在两个端点之间使用任何自己设计的协议，进而创建出各种各样的TCP通信，当然浏览器不会让开发者随意去这么做，而是要指定某些协议，WebSocket应运而生！\n我们来看一个截图：  \n![这里写图片描述](http://img.blog.csdn.net/20170827204229481?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjcwMjU0Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n## 使用HTTP/1.1升级的WebSocket协议\nOK，了解了HTTP/1.1协议的升级特性之后，我们再来详细看看整个过程是怎么样的？  \n一个WebSocket请求首先使用非正常的HTTP请求以特定的模式访问一个URL，这个URL有两种模式，分别是ws和wss，对应HTTP协议中的http和https，请求头中除了Connection:Upgrade之外还有一个Upgrade:websocket,它们两个将共同告诉服务器将连接升级为WebSocket这样一种全双工协议。如此，在握手完成之后，文本消息或者其他二进制消息就可以同时在两个方向上进行发送，而不需要关闭和重建连接。此时的客户端和服务端关系其实是对等的，他们都可以互相向对方主动发消息。那么这里有一点需要注意：那就是ws和wss模式并不能算作HTTP协议的一部分，因为HTTP请求和请求头并不包含URL模式，HTTP请求只在请求的第一行中包含相对于服务器的URL，在Host头中包含域名，而WebSocket中特有的ws和wss模式主要用于通知浏览器和API是希望使用SSL/TLS(wss)，还是希望使用不加密的方式(ws)进行连接。\n## WebSocket协议的优势\n说了这么多，那么接下来我们来看看WebSocket协议都有哪些优势：\n>1.由于WebSocket连接在端口80(ws)或者443(wss)上创建，与HTTP使用的端口相同，这样，基本上所有的防火墙都不会阻塞WebSocket连接  \n\n>2.WebSocket使用HTTP协议进行握手，因此它可以自然而然的集成到网络浏览器和HTTP服务器中  \n\n>3.心跳消息(ping和pong)将被反复的发送，进而保持WebSocket连接几乎一直处于活跃状态。一般来说是这样，一个节点周期性的发送一个小数据包到另外一个节点(ping)，而另一个节点则使用了包含了相同数据的数据包作为响应(pong),这样两个节点都将处于连接状态  \n\n>4.使用该协议，当消息启动或者到达的时候，服务端和客户端都可以知道  \n\n>5.WebSocket连接关闭时将发送一个特殊的关闭消息  \n\n>6.WebSocket支持跨域，可以避免Ajax的限制  \n\n>7.HTTP规范要求浏览器将并发连接数限制为每个主机名两个连接，但是当我们使用WebSocket的时候，当握手完成之后该限制就不存在了，因为此时的连接已经不再是HTTP连接了  \n## WebSocket协议的用途\n\n说了这么多那么WebSocket协议到底可以用在哪些地方呢？事实上，WebSocket协议的用途几乎是没有限制的，比如：\n\n>1.网页上的在线聊天   \n\n>2.多人在线游戏   \n\n>3.在线股票网站   \n\n>4.在线即时新闻网站   \n\n>5.高清视频流   \n\n>6.应用集群之间的通信  \n\n>7.远程系统/软件的状态和性能的实时监控 \n\n\n# 结语  \n\n说了这么多，可能很多小伙伴觉得这个WebSocket貌似用起来很麻烦，其实不麻烦，所有的东西都有对应的API来帮助我们实现，<big>**小伙伴们稍安勿躁，我们将在下篇文章中来介绍WebSocket的实战应用。**</big>\n\n参考资料：《JavaEE 编程》\n\n更多JavaEE资料请关注公众号  \n![这里写图片描述](http://img.blog.csdn.net/20170827204306560?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjcwMjU0Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n以上。\n', '<p>年初的时候，写过两篇博客介绍在Spring Boot中如何使用WebSocket发送消息【<a href=\"http://blog.csdn.net/u012702547/article/details/53816326\" target=\"_blank\">在Spring Boot框架下使用WebSocket实现消息推送</a>】【<a href=\"http://blog.csdn.net/u012702547/article/details/53835453\" target=\"_blank\">在Spring Boot框架下使用WebSocket实现聊天功能</a>】，最近看到很多小伙伴对WebSocket的讨论还比较火热，so，打算写几篇文章来系统的介绍下websocket。OK，废话不多说，下面开始我们的正文。</p>\n<hr />\n<h1>为什么要有WebSocket这个技术</h1>\n<p>大家都知道，HTML页面在刚刚开始出现的时候是静态的，不能够进行交互，后来有了JavaScript，在一定程度上解决了这个问题，但是JavaScript刚出现的时候并不能和服务端进行交互，直到Ajax的出现。Ajax有效的解决了页面和服务端进行交互的问题，不过Ajax有一个问题，就是所有的请求都必须由客户端发起，服务端进行响应，如果服务端有最新的消息，难以即时的发送到客户端去，在WebSocket技术出现之前，为了让客户端能够即时的获取服务端的数据，一般采用如下三种方案：</p>\n<h2>轮询</h2>\n<p>这是最简单的一种解决方案， 就是客户端在固定的时间间隔下（一般是1秒）不停的向服务器端发送请求，查看服务端是否有最新的数据，服务端如果有最新的数据则返回给客户端，服务端如果没有则返回一个空的json或者xml文档，这种方式的实现起来简单，但是弊端也很明显，就是会有大量的无效请求，服务端的资源被大大的浪费了。</p>\n<h2>长连接</h2>\n<p>长连接有点类似于轮询，不同的是服务端不是每次都会响应客户端的请求，只有在服务端有最新数据的时候才会响应客户端的请求，这种方式很明显会节省网络资源和服务端资源，但是也存在一些问题，比如：</p>\n<blockquote>\n<p>1.如果浏览器在服务器响应之前有新数据要发送就只能创建一个新的并发请求，或者先尝试断掉当前请求然后再创建新的请求。<br />\n2.TCP和HTTP规范中都有连接超时一说，所以所谓的长连接并不能一直持续，服务端和客户端的连接需要定期的连接和关闭再连接，当然也有一些技术能够延长每次连接的时间，这是题外话。</p>\n</blockquote>\n<h2>Applet和Flash</h2>\n<p>Applet和Flash都已经是明日黄花了，不过这两个技术在当年除了可以让我们的HTML页面更加绚丽之外，还可以解决消息推送问题。在Ajax这种技术去实现全双工通信已经陷入困境的时候，开发者试图用Applet和Flash来模拟全双工通信，开发者可以创建一个只有1个像素点大小的普通透明的Applet或者Flash，然后将之内嵌在页面中， 然后这个Applet或者Flash中的代码创建出一个Socket连接，这种连接方式消除了HTTP协议中的各种限制，当服务器有消息发送到客户端的时候，开发者可以在Applet或者Flash中调用JavaScript函数，并将服务器传来的消息传递给JavaScript函数，然后更新页面，当浏览器有数据要发送给服务器的时候，也一样，通过Applet或者Flash来传递。这种方式真正的实现了全双工通信，不过也有问题，如下：</p>\n<blockquote>\n<p>1.浏览器必须能够运行Java或者Flash<br />\n2.无论是Applet还是Flash都存在安全问题<br />\n3.随着HTML5在标准在浏览器中广泛支持，Flash下架已经被提上日程(<a href=\"http://tech.163.com/17/0726/07/CQ8M4HT200097U7T.html\" target=\"_blank\"><br />\n终于要放弃，Adobe宣布2020年正式停止支持Flash</a>)</p>\n</blockquote>\n<h1>WebSocket有哪些特点</h1>\n<p>既然上面这些技术都不行，那么谁行？当然是我WebSocket了！</p>\n<h2>HTTP/1.1的升级特性</h2>\n<p>要说WebSocket协议，我们得先来说说HTTP协议的一个请求头，事实上，所有的HTTP客户端（浏览器、移动端等）都可以在请求头中包含Connection:Upgrade，这个表示客户端希望升级请求协议，那么希望升级成什么样的协议呢？我们需要在Upgrade头中指定一个或者多个协议的列表，当然这些协议必须兼容HTTP/1.1协议。服务器收到请求之后，如果接受升级请求，那么将会返回一个101的状态码，表示转换请求协议，同时在响应的Upgrade头中使用单个值，这个单个值就是请求协议列表中服务器支持的第一个协议（即请求头的Upgrade字段中列出来的协议列表中服务器支持的第一个协议）。<br />\nHTTP升级最大的好处是最终使我们可以使用任意的协议，在升级握手完成之后，它就不再使用HTTP连接了，我们甚至可以在升级握手完成之后建立一个Socket连接，理论上我们可以使用HTTP升级在两个端点之间使用任何自己设计的协议，进而创建出各种各样的TCP通信，当然浏览器不会让开发者随意去这么做，而是要指定某些协议，WebSocket应运而生！<br />\n我们来看一个截图：<br />\n<img src=\"http://img.blog.csdn.net/20170827204229481?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjcwMjU0Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" /></p>\n<h2>使用HTTP/1.1升级的WebSocket协议</h2>\n<p>OK，了解了HTTP/1.1协议的升级特性之后，我们再来详细看看整个过程是怎么样的？<br />\n一个WebSocket请求首先使用非正常的HTTP请求以特定的模式访问一个URL，这个URL有两种模式，分别是ws和wss，对应HTTP协议中的http和https，请求头中除了Connection:Upgrade之外还有一个Upgrade:websocket,它们两个将共同告诉服务器将连接升级为WebSocket这样一种全双工协议。如此，在握手完成之后，文本消息或者其他二进制消息就可以同时在两个方向上进行发送，而不需要关闭和重建连接。此时的客户端和服务端关系其实是对等的，他们都可以互相向对方主动发消息。那么这里有一点需要注意：那就是ws和wss模式并不能算作HTTP协议的一部分，因为HTTP请求和请求头并不包含URL模式，HTTP请求只在请求的第一行中包含相对于服务器的URL，在Host头中包含域名，而WebSocket中特有的ws和wss模式主要用于通知浏览器和API是希望使用SSL/TLS(wss)，还是希望使用不加密的方式(ws)进行连接。</p>\n<h2>WebSocket协议的优势</h2>\n<p>说了这么多，那么接下来我们来看看WebSocket协议都有哪些优势：</p>\n<blockquote>\n<p>1.由于WebSocket连接在端口80(ws)或者443(wss)上创建，与HTTP使用的端口相同，这样，基本上所有的防火墙都不会阻塞WebSocket连接</p>\n</blockquote>\n<blockquote>\n<p>2.WebSocket使用HTTP协议进行握手，因此它可以自然而然的集成到网络浏览器和HTTP服务器中</p>\n</blockquote>\n<blockquote>\n<p>3.心跳消息(ping和pong)将被反复的发送，进而保持WebSocket连接几乎一直处于活跃状态。一般来说是这样，一个节点周期性的发送一个小数据包到另外一个节点(ping)，而另一个节点则使用了包含了相同数据的数据包作为响应(pong),这样两个节点都将处于连接状态</p>\n</blockquote>\n<blockquote>\n<p>4.使用该协议，当消息启动或者到达的时候，服务端和客户端都可以知道</p>\n</blockquote>\n<blockquote>\n<p>5.WebSocket连接关闭时将发送一个特殊的关闭消息</p>\n</blockquote>\n<blockquote>\n<p>6.WebSocket支持跨域，可以避免Ajax的限制</p>\n</blockquote>\n<blockquote>\n<p>7.HTTP规范要求浏览器将并发连接数限制为每个主机名两个连接，但是当我们使用WebSocket的时候，当握手完成之后该限制就不存在了，因为此时的连接已经不再是HTTP连接了</p>\n</blockquote>\n<h2>WebSocket协议的用途</h2>\n<p>说了这么多那么WebSocket协议到底可以用在哪些地方呢？事实上，WebSocket协议的用途几乎是没有限制的，比如：</p>\n<blockquote>\n<p>1.网页上的在线聊天</p>\n</blockquote>\n<blockquote>\n<p>2.多人在线游戏</p>\n</blockquote>\n<blockquote>\n<p>3.在线股票网站</p>\n</blockquote>\n<blockquote>\n<p>4.在线即时新闻网站</p>\n</blockquote>\n<blockquote>\n<p>5.高清视频流</p>\n</blockquote>\n<blockquote>\n<p>6.应用集群之间的通信</p>\n</blockquote>\n<blockquote>\n<p>7.远程系统/软件的状态和性能的实时监控</p>\n</blockquote>\n<h1>结语</h1>\n<p>说了这么多，可能很多小伙伴觉得这个WebSocket貌似用起来很麻烦，其实不麻烦，所有的东西都有对应的API来帮助我们实现，<big><strong>小伙伴们稍安勿躁，我们将在下篇文章中来介绍WebSocket的实战应用。</strong></big></p>\n<p>参考资料：《JavaEE 编程》</p>\n<p>更多JavaEE资料请关注公众号<br />\n<img src=\"http://img.blog.csdn.net/20170827204306560?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjcwMjU0Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" /></p>\n<p>以上。</p>\n','2017-12-21 22:33:31', '2017-12-21 22:33:31','紧急','这是备注2','1','10',8,2);
INSERT INTO `information` VALUES ('3', '华数','社区','元旦活动', '智能组网','summary办指定299套餐宽带送指定智能家电','上篇文章【[WebSocket刨根问底(一)](http://blog.csdn.net/u012702547/article/details/77621195)】中我们对WebSocket的一些基本理论进行了介绍，但是并没有过多的涉及到一些实战的内容，今天我希望能够用几个简单的案例来向小伙伴们展示下WebSocket的一些具体用法。\n# WebSocket API有哪些\n首先有一点小伙伴们需要明确，那就是WebSocket并不总是用在浏览器和服务器的通信中，只要任意两个使用框架编写，支持WebSocket的应用程序都可以创建WebSocket连接进行通信，基于此，许多WebSocket实现在客户端或者服务器终端工具中都是可用的，比如Java或者***.***NET等。我们这里主要是介绍Java WebSocket和javascript中的websocket的使用，js中websocket的使用这个好理解，就是扮演一个客户端的角色，Java中的WebSocket分两种角色，一种是Java客户端终端的WebSocket（作用类似于JavaScript中的WebSocket），还有一种角色是Java服务器终端。本文主要介绍javascript中websocket的使用以及java服务器终端中websocket的使用，java客户端使用websocket这种情形并不多见，不在本文讨论的范围之内。\n# JavaScript中WebSocket的使用\n目前基本上只要的浏览器不是古董级的，基本上都支持WebSocket了，w3c目前已经统一了浏览器中websocket通信的标准和接口，所有的浏览器都通过WebSocket接口的实现提供WebSocket通信。举几个简单的API我们来看看：  \n\n## 1.创建一个WebSocket对象  \n```\nvar webSocket = new WebSocket(\"ws://localhost/myws\");\n```  \n## 2.WebSocket中几个常见属性  \nreadyState表示当前WebSocket的连接状态，有四种不同的取值,分别是CONNECTING(0),OPEN(1),CLOSING(2)和CLOSED(3)  \n```if(webSocket.readyState==WebSocket.OPEN){/*do something*/}```  \n\n\n## 3.几个常见方法 \n\n``` \n	\n	webSocket.onopen=function (event) {\n    	//连接成功时触发    \n    }\n    webSocket.onclose=function (event) {\n    	//连接关闭时触发    \n    }\n    webSocket.onerror=function (event) {\n    	//连接出错时触发    \n    }\n    webSocket.onmessage=function (event) {\n    	//收到消息时触发    \n    }\n\n\n```\n\n# Java服务端中WebSocket的使用\n\nJava服务端中WebSocket 的使用有几个点需要注意下，首先Java服务端的WebSocket想要使用，你的Tomcat必须得是Tomcat7以上的版本，Tomcat7才开始了对WebSocket的支持，不过这个条件想必小伙伴们都能满足吧！Java服务端WebSocket的使用主要是有几个注解需要我们了解下用法。如下：  \n\n```\n\n    @ServerEndpoint(\"/myws\")\n    public class WebSocketServer {\n	    @OnMessage\n	    public void onMessage(String message, Session session) throws IOException {\n	        System.out.println(\"收到了客户端发来的消息：\" + message);\n	        session.getBasicRemote().sendText(\"服务端返回：\" + message);\n	    }\n	\n	    @OnOpen\n	    public void onOpen(Session session) throws IOException {\n	        System.out.println(\"客户端连接成功\");\n	    }\n	\n	    @OnClose\n	    public void onClose(Session session) throws IOException {\n	        session.getBasicRemote().sendText(\"连接关闭\");\n	        System.out.println(\"连接关闭\");\n	    }\n    }\n\n```\n\n关于这个类我说如下几点：\n>1.@ServerEndPoint注解表示将该类升级为一个WebSocket服务端点  \n>2.@OnMessage注解表示收到客户端发来的消息时触发  \n>3.@OnOpen注解表示当客户端连接上服务端时触发  \n>4.@OnClose注解表示当连接关闭时触发  \n\n---\nOK，经过上面的介绍，我们对WebSocket的API已经有了一个大概的了解，那么接下来我们就来通过一个简单的案例来看看WebSocket的使用。\n\n# 一个简单的互发消息的案例\n## 创建工程\n首先创建一个普通的Java Web工程，正常情况下我们创建一个Java Web工程，这个工程如下：  \n\n![这里写图片描述](http://img.blog.csdn.net/20170828205157703?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjcwMjU0Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n大家看到这个工程中是引用的Tomcat是只引用了Tomcat中的两个Jar包，websocket的jar默认情况下并没有引入，这个需要我们自己手动引入，引入方式也很简单，如下：\n\n1.选中当前工程，右键单击，点击open module setting，打开工程的设置页面：  \n\n![这里写图片描述](http://img.blog.csdn.net/20170828205247335?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjcwMjU0Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n2.找到Tomcat文件夹下的lib包中的websocket的jar添加进来即可，如下：  \n\n![这里写图片描述](http://img.blog.csdn.net/20170828205434340?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjcwMjU0Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n3.添加之后，我们的现在的工程是这个样子的：  \n\n![这里写图片描述](http://img.blog.csdn.net/20170828205612465?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjcwMjU0Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n## 创建HTML页面\n创建HTML页面，编写JavaScript中的websocket逻辑，页面显示如下：  \n\n![这里写图片描述](http://img.blog.csdn.net/20170828205917224?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjcwMjU0Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n首先我们点击连接按钮连接上服务端，然后再点击发送按钮向服务端发送消息，代码如下：\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>ws页面</title>\n    <script src=\"jquery-3.2.1.js\"></script>\n</head>\n<body>\n<input type=\"button\" value=\"连接\" id=\"btnClick1\"><br>\n<input type=\"text\" id=\"msg\"><input type=\"button\" value=\"发送\" id=\"btnClick2\">\n</div>\n<div id=\"resultDiv\"></div>\n<script>\n    var webSocket;\n\n    $(\"#btnClick2\").click(function () {\n        var msg = $(\"#msg\").val();\n        $(\"#resultDiv\").append(\"<p>发送消息:\" + msg+\"</p>\");\n        webSocket.send(msg)\n    });\n    $(\"#btnClick1\").click(function () {\n        $(\"#resultDiv\").append(\"<p>开始连接服务端!</p>\");\n        webSocket = new WebSocket(\"ws://localhost/myws\");\n        webSocket.onerror = function (event) {\n            $(\"#resultDiv\").append(\"<p>onerror:\" + event.data + \"</p>\");\n        }\n        webSocket.onopen = function (event) {\n            $(\"#resultDiv\").append(\"<p>连接成功！</p>\");\n        }\n        webSocket.onmessage = function (event) {\n            $(\"#resultDiv\").append(\"<p>onmessage:\" + event.data + \"</p>\");\n        }\n    });\n\n</script>\n</body>\n</html>\n```\n\n这里涉及到的API的含义我们在上文已经介绍过，这里就不再赘述。\n\n## 创建服务端  \n服务端也比较简单，如下：\n\n```\n@ServerEndpoint(\"/myws\")\npublic class WebSocketServer {\n    @OnMessage\n    public void onMessage(String message, Session session) throws IOException {\n        System.out.println(\"收到了客户端发来的消息：\" + message);\n        session.getBasicRemote().sendText(\"服务端返回：\" + message);\n    }\n\n    @OnOpen\n    public void onOpen(Session session) throws IOException {\n        System.out.println(\"客户端连接成功\");\n    }\n\n    @OnClose\n    public void onClose(Session session) throws IOException {\n        session.getBasicRemote().sendText(\"连接关闭\");\n        System.out.println(\"连接关闭\");\n    }\n}\n```\n\n服务端API的含义我们上文也已经介绍过了，这里我再补充一个小问题，小伙伴们可能看到我们不同的方法里边都有参数，参数的个数和类型都有差异，实际上这里的参数是可变的，这里的具体信息我们会在下一篇文章中详说，这里先这样来写。  \n\nOk，我们的代码写完了。\n\n## 部署测试\n工程的运行就像普通的JavaWeb工程那样，直接运行即可，运行之后，打开html页面，效果如下：  \n\n![这里写图片描述](http://img.blog.csdn.net/20170828211153828?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjcwMjU0Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\nOK，本文先说到这里，下篇文章我们再来详细介绍一个群聊的应用，继续深入使用WebSocket。\n\n工程下载：（由于CSDN下载现在必须要积分，不得已设置了1分，如果小伙伴没有积分，文末留言我发给你。）\n\n更多JavaEE资料请关注公众号：  \n\n![这里写图片描述](http://img.blog.csdn.net/20170828211355113?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjcwMjU0Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n以上。。\n\n', '<p>上篇文章【<a href=\"http://blog.csdn.net/u012702547/article/details/77621195\" target=\"_blank\">WebSocket刨根问底(一)</a>】中我们对WebSocket的一些基本理论进行了介绍，但是并没有过多的涉及到一些实战的内容，今天我希望能够用几个简单的案例来向小伙伴们展示下WebSocket的一些具体用法。</p>\n<h1>WebSocket API有哪些</h1>\n<p>首先有一点小伙伴们需要明确，那就是WebSocket并不总是用在浏览器和服务器的通信中，只要任意两个使用框架编写，支持WebSocket的应用程序都可以创建WebSocket连接进行通信，基于此，许多WebSocket实现在客户端或者服务器终端工具中都是可用的，比如Java或者***.***NET等。我们这里主要是介绍Java WebSocket和javascript中的websocket的使用，js中websocket的使用这个好理解，就是扮演一个客户端的角色，Java中的WebSocket分两种角色，一种是Java客户端终端的WebSocket（作用类似于JavaScript中的WebSocket），还有一种角色是Java服务器终端。本文主要介绍javascript中websocket的使用以及java服务器终端中websocket的使用，java客户端使用websocket这种情形并不多见，不在本文讨论的范围之内。</p>\n<h1>JavaScript中WebSocket的使用</h1>\n<p>目前基本上只要的浏览器不是古董级的，基本上都支持WebSocket了，w3c目前已经统一了浏览器中websocket通信的标准和接口，所有的浏览器都通过WebSocket接口的实现提供WebSocket通信。举几个简单的API我们来看看：</p>\n<h2>1.创建一个WebSocket对象</h2>\n<pre><code class=\"lang-\">var webSocket = new WebSocket(&quot;ws://localhost/myws&quot;);\n</code></pre>\n<h2>2.WebSocket中几个常见属性</h2>\n<p>readyState表示当前WebSocket的连接状态，有四种不同的取值,分别是CONNECTING(0),OPEN(1),CLOSING(2)和CLOSED(3)<br />\n<code>if(webSocket.readyState==WebSocket.OPEN){/*do something*/}</code></p>\n<h2>3.几个常见方法</h2>\n<pre><code class=\"lang-\">	\n	webSocket.onopen=function (event) {\n    	//连接成功时触发    \n    }\n    webSocket.onclose=function (event) {\n    	//连接关闭时触发    \n    }\n    webSocket.onerror=function (event) {\n    	//连接出错时触发    \n    }\n    webSocket.onmessage=function (event) {\n    	//收到消息时触发    \n    }\n\n\n</code></pre>\n<h1>Java服务端中WebSocket的使用</h1>\n<p>Java服务端中WebSocket 的使用有几个点需要注意下，首先Java服务端的WebSocket想要使用，你的Tomcat必须得是Tomcat7以上的版本，Tomcat7才开始了对WebSocket的支持，不过这个条件想必小伙伴们都能满足吧！Java服务端WebSocket的使用主要是有几个注解需要我们了解下用法。如下：</p>\n<pre><code class=\"lang-\">\n    @ServerEndpoint(&quot;/myws&quot;)\n    public class WebSocketServer {\n	    @OnMessage\n	    public void onMessage(String message, Session session) throws IOException {\n	        System.out.println(&quot;收到了客户端发来的消息：&quot; + message);\n	        session.getBasicRemote().sendText(&quot;服务端返回：&quot; + message);\n	    }\n	\n	    @OnOpen\n	    public void onOpen(Session session) throws IOException {\n	        System.out.println(&quot;客户端连接成功&quot;);\n	    }\n	\n	    @OnClose\n	    public void onClose(Session session) throws IOException {\n	        session.getBasicRemote().sendText(&quot;连接关闭&quot;);\n	        System.out.println(&quot;连接关闭&quot;);\n	    }\n    }\n\n</code></pre>\n<p>关于这个类我说如下几点：</p>\n<blockquote>\n<p>1.@ServerEndPoint注解表示将该类升级为一个WebSocket服务端点<br />\n2.@OnMessage注解表示收到客户端发来的消息时触发<br />\n3.@OnOpen注解表示当客户端连接上服务端时触发<br />\n4.@OnClose注解表示当连接关闭时触发</p>\n</blockquote>\n<hr />\n<p>OK，经过上面的介绍，我们对WebSocket的API已经有了一个大概的了解，那么接下来我们就来通过一个简单的案例来看看WebSocket的使用。</p>\n<h1>一个简单的互发消息的案例</h1>\n<h2>创建工程</h2>\n<p>首先创建一个普通的Java Web工程，正常情况下我们创建一个Java Web工程，这个工程如下：</p>\n<p><img src=\"http://img.blog.csdn.net/20170828205157703?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjcwMjU0Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" /></p>\n<p>大家看到这个工程中是引用的Tomcat是只引用了Tomcat中的两个Jar包，websocket的jar默认情况下并没有引入，这个需要我们自己手动引入，引入方式也很简单，如下：</p>\n<p>1.选中当前工程，右键单击，点击open module setting，打开工程的设置页面：</p>\n<p><img src=\"http://img.blog.csdn.net/20170828205247335?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjcwMjU0Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" /></p>\n<p>2.找到Tomcat文件夹下的lib包中的websocket的jar添加进来即可，如下：</p>\n<p><img src=\"http://img.blog.csdn.net/20170828205434340?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjcwMjU0Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" /></p>\n<p>3.添加之后，我们的现在的工程是这个样子的：</p>\n<p><img src=\"http://img.blog.csdn.net/20170828205612465?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjcwMjU0Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" /></p>\n<h2>创建HTML页面</h2>\n<p>创建HTML页面，编写JavaScript中的websocket逻辑，页面显示如下：</p>\n<p><img src=\"http://img.blog.csdn.net/20170828205917224?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjcwMjU0Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" /></p>\n<p>首先我们点击连接按钮连接上服务端，然后再点击发送按钮向服务端发送消息，代码如下：</p>\n<pre><code class=\"lang-\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;ws页面&lt;/title&gt;\n    &lt;script src=&quot;jquery-3.2.1.js&quot;&gt;&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;input type=&quot;button&quot; value=&quot;连接&quot; id=&quot;btnClick1&quot;&gt;&lt;br&gt;\n&lt;input type=&quot;text&quot; id=&quot;msg&quot;&gt;&lt;input type=&quot;button&quot; value=&quot;发送&quot; id=&quot;btnClick2&quot;&gt;\n&lt;/div&gt;\n&lt;div id=&quot;resultDiv&quot;&gt;&lt;/div&gt;\n&lt;script&gt;\n    var webSocket;\n\n    $(&quot;#btnClick2&quot;).click(function () {\n        var msg = $(&quot;#msg&quot;).val();\n        $(&quot;#resultDiv&quot;).append(&quot;&lt;p&gt;发送消息:&quot; + msg+&quot;&lt;/p&gt;&quot;);\n        webSocket.send(msg)\n    });\n    $(&quot;#btnClick1&quot;).click(function () {\n        $(&quot;#resultDiv&quot;).append(&quot;&lt;p&gt;开始连接服务端!&lt;/p&gt;&quot;);\n        webSocket = new WebSocket(&quot;ws://localhost/myws&quot;);\n        webSocket.onerror = function (event) {\n            $(&quot;#resultDiv&quot;).append(&quot;&lt;p&gt;onerror:&quot; + event.data + &quot;&lt;/p&gt;&quot;);\n        }\n        webSocket.onopen = function (event) {\n            $(&quot;#resultDiv&quot;).append(&quot;&lt;p&gt;连接成功！&lt;/p&gt;&quot;);\n        }\n        webSocket.onmessage = function (event) {\n            $(&quot;#resultDiv&quot;).append(&quot;&lt;p&gt;onmessage:&quot; + event.data + &quot;&lt;/p&gt;&quot;);\n        }\n    });\n\n&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>这里涉及到的API的含义我们在上文已经介绍过，这里就不再赘述。</p>\n<h2>创建服务端</h2>\n<p>服务端也比较简单，如下：</p>\n<pre><code class=\"lang-\">@ServerEndpoint(&quot;/myws&quot;)\npublic class WebSocketServer {\n    @OnMessage\n    public void onMessage(String message, Session session) throws IOException {\n        System.out.println(&quot;收到了客户端发来的消息：&quot; + message);\n        session.getBasicRemote().sendText(&quot;服务端返回：&quot; + message);\n    }\n\n    @OnOpen\n    public void onOpen(Session session) throws IOException {\n        System.out.println(&quot;客户端连接成功&quot;);\n    }\n\n    @OnClose\n    public void onClose(Session session) throws IOException {\n        session.getBasicRemote().sendText(&quot;连接关闭&quot;);\n        System.out.println(&quot;连接关闭&quot;);\n    }\n}\n</code></pre>\n<p>服务端API的含义我们上文也已经介绍过了，这里我再补充一个小问题，小伙伴们可能看到我们不同的方法里边都有参数，参数的个数和类型都有差异，实际上这里的参数是可变的，这里的具体信息我们会在下一篇文章中详说，这里先这样来写。</p>\n<p>Ok，我们的代码写完了。</p>\n<h2>部署测试</h2>\n<p>工程的运行就像普通的JavaWeb工程那样，直接运行即可，运行之后，打开html页面，效果如下：</p>\n<p><img src=\"http://img.blog.csdn.net/20170828211153828?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjcwMjU0Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" /></p>\n<p>OK，本文先说到这里，下篇文章我们再来详细介绍一个群聊的应用，继续深入使用WebSocket。</p>\n<p>工程下载：（由于CSDN下载现在必须要积分，不得已设置了1分，如果小伙伴没有积分，文末留言我发给你。）</p>\n<p>更多JavaEE资料请关注公众号：</p>\n<p><img src=\"http://img.blog.csdn.net/20170828211355113?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjcwMjU0Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" /></p>\n<p>以上。。</p>\n','2017-12-21 22:34:02', '2017-12-21 22:34:02','紧急','这是备注3','1','30',8,3);

-- ----------------------------
-- Table structure for tags
-- ----------------------------
DROP TABLE IF EXISTS `tags`;
CREATE TABLE `tags` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `tagName` varchar(32) DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `tagName` (`tagName`)
) ENGINE=InnoDB AUTO_INCREMENT=67 DEFAULT CHARSET=utf8;
-- ----------------------------
-- Records of tags
-- ----------------------------
INSERT INTO `tags` VALUES ('66', '666');
INSERT INTO `tags` VALUES ('35', 'A小区');
INSERT INTO `tags` VALUES ('36', 'B小区');
INSERT INTO `tags` VALUES ('40', 'C小区');
INSERT INTO `tags` VALUES ('33', 'D小区');
INSERT INTO `tags` VALUES ('45', 'E小区');
INSERT INTO `tags` VALUES ('42', 'F小区');
INSERT INTO `tags` VALUES ('44', 'G小区');
INSERT INTO `tags` VALUES ('37', 'H小区');
INSERT INTO `tags` VALUES ('34', 'I小区');
INSERT INTO `tags` VALUES ('50', 'J小区');
INSERT INTO `tags` VALUES ('51', 'K小区');
INSERT INTO `tags` VALUES ('41', 'L小区');
INSERT INTO `tags` VALUES ('65', 'M小区');

-- ----------------------------
-- Table structure for information_tags
-- ----------------------------
DROP TABLE IF EXISTS `information_tags`;
CREATE TABLE `information_tags` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `iid` int(11) DEFAULT NULL,
  `tid` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `tid` (`tid`),
  KEY `information_tags_ibfk_1` (`iid`),
  CONSTRAINT `information_tags_ibfk_1` FOREIGN KEY (`iid`) REFERENCES `information` (`id`) ON DELETE CASCADE,
  CONSTRAINT `information_tags_ibfk_2` FOREIGN KEY (`tid`) REFERENCES `tags` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=52 DEFAULT CHARSET=utf8;
-- ----------------------------
-- Records of article_tags
-- ----------------------------
INSERT INTO `information_tags` VALUES ('26', '1', '35');
INSERT INTO `information_tags` VALUES ('27', '12', '36');
INSERT INTO `information_tags` VALUES ('28', '13', '40');

-- ----------------------------
-- Table structure for category
-- ----------------------------
DROP TABLE IF EXISTS `category`;
CREATE TABLE `category` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `cateName` varchar(64) DEFAULT NULL,
  `date` date DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=65 DEFAULT CHARSET=utf8;
-- ----------------------------
-- Records of category
-- ----------------------------
INSERT INTO `category` VALUES ('1', '移动类情报', '2019-09-20');
INSERT INTO `category` VALUES ('2', '宽带类情报', '2019-09-20');
INSERT INTO `category` VALUES ('3', 'ITV类情报', '2019-09-20');
INSERT INTO `category` VALUES ('4', '智能组网类情报', '2019-09-20');
INSERT INTO `category` VALUES ('5', '政企业务情报', '2019-09-20');
INSERT INTO `category` VALUES ('6', 'IDC业务情报', '2019-09-20');

-- ----------------------------
-- Table structure for information_detail
-- ----------------------------
DROP TABLE IF EXISTS `msgcontent`;
CREATE TABLE `msgcontent` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `title` varchar(64) DEFAULT NULL,
  `message` varchar(255) DEFAULT NULL,
  `createDate` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=19 DEFAULT CHARSET=utf8;
-- ----------------------------
-- Records of msgcontent
-- ----------------------------
INSERT INTO `msgcontent` VALUES ('1', '2222222222', '11111111111111111', '2018-02-02 20:46:19');
INSERT INTO `msgcontent` VALUES ('2', '22222222', '3333333333333333333333', '2018-02-02 21:45:57');
INSERT INTO `msgcontent` VALUES ('3', '通知标题1', '通知内容1', '2018-02-03 11:41:39');
INSERT INTO `msgcontent` VALUES ('4', '通知标题2', '通知内容2', '2018-02-03 11:52:37');
INSERT INTO `msgcontent` VALUES ('5', '通知标题3', '通知内容3', '2018-02-03 12:19:41');

-- ----------------------------
-- Table structure for sysmsg
-- ----------------------------
DROP TABLE IF EXISTS `sysmsg`;
CREATE TABLE `sysmsg` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `type` int(11) DEFAULT '0' COMMENT '0表示群发消息',
  `userId` int(11) DEFAULT NULL COMMENT '这条消息是给谁的',
   `mid` int(11) DEFAULT NULL COMMENT '消息id',
  PRIMARY KEY (`id`),
  KEY `userId` (`userId`),
  KEY `mid` (`mid`),
  CONSTRAINT `sysmsg_ibfk_1` FOREIGN KEY (`mid`) REFERENCES `msgcontent` (`id`),
  CONSTRAINT `sysmsg_ibfk_2` FOREIGN KEY (`userId`) REFERENCES `user` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
-- ----------------------------
-- Records of sysmsg
-- ----------------------------
INSERT INTO `sysmsg` VALUES ('57',  '0','8', '3');
INSERT INTO `sysmsg` VALUES ('58', '0','6', '5');
INSERT INTO `sysmsg` VALUES ('59', '0','8', '4');
INSERT INTO `sysmsg` VALUES ('60', '0','6', '1');
INSERT INTO `sysmsg` VALUES ('61',  '0','6', '2');
-- INSERT INTO `sysmsg` VALUES ('62',  '0','8', '2');
-- INSERT INTO `sysmsg` VALUES ('63',  '0','8', '5');
-- INSERT INTO `sysmsg` VALUES ('64',  '0','8', '10');
-- INSERT INTO `sysmsg` VALUES ('65',  '0','6', '11');
-- INSERT INTO `sysmsg` VALUES ('66',  '0','8', '12');

-- ----------------------------
-- Table structure for strategy
-- ----------------------------
DROP TABLE IF EXISTS `strategy`;
CREATE TABLE `strategy` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `strTitle` varchar(200) not null ,
  `mdContent` text COMMENT 'md文件源码',
  `htmlContent` text COMMENT 'html源码',
  `summary` text COMMENT '简述',
  `state` int(11) DEFAULT NULL COMMENT '1表示已发表，2表示已删除',
  `income` varchar(255) not null COMMENT '简述对收入的影响',
  `uid` int(11) DEFAULT NULL,
  `iid` int(11) not NULL ,
  PRIMARY KEY (`id`),
  KEY `iid` (`iid`),
  KEY `uid` (`uid`),
  CONSTRAINT `strategy_ibfk_1` FOREIGN KEY (`iid`) REFERENCES `information` (`id`),
  CONSTRAINT `strategy_ibfk_2` FOREIGN KEY (`uid`) REFERENCES `user` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
-- ----------------------------
-- Records of strategy
-- ----------------------------
INSERT INTO `strategy` VALUES ('1',  '应对竞争信息1','年初的时候，写过两篇博客介绍在Spring Boot中如何使用WebSocket发送消息【[在Spring Boot框架下使用WebSocket实现消息推送](http://blog.csdn.net/u012702547/article/details/53816326)】【[在Spring Boot框架下使用WebSocket实现聊天功能](http://blog.csdn.net/u012702547/article/details/53835453)】，最近看到很多小伙伴对WebSocket的讨论还比较火热，so，打算写几篇文章来系统的介绍下websocket。OK，废话不多说，下面开始我们的正文。\n\n---\n# 为什么要有WebSocket这个技术\n\n大家都知道，HTML页面在刚刚开始出现的时候是静态的，不能够进行交互，后来有了JavaScript，在一定程度上解决了这个问题，但是JavaScript刚出现的时候并不能和服务端进行交互，直到Ajax的出现。Ajax有效的解决了页面和服务端进行交互的问题，不过Ajax有一个问题，就是所有的请求都必须由客户端发起，服务端进行响应，如果服务端有最新的消息，难以即时的发送到客户端去，在WebSocket技术出现之前，为了让客户端能够即时的获取服务端的数据，一般采用如下三种方案：\n## 轮询\n这是最简单的一种解决方案， 就是客户端在固定的时间间隔下（一般是1秒）不停的向服务器端发送请求，查看服务端是否有最新的数据，服务端如果有最新的数据则返回给客户端，服务端如果没有则返回一个空的json或者xml文档，这种方式的实现起来简单，但是弊端也很明显，就是会有大量的无效请求，服务端的资源被大大的浪费了。\n## 长连接\n长连接有点类似于轮询，不同的是服务端不是每次都会响应客户端的请求，只有在服务端有最新数据的时候才会响应客户端的请求，这种方式很明显会节省网络资源和服务端资源，但是也存在一些问题，比如：\n>1.如果浏览器在服务器响应之前有新数据要发送就只能创建一个新的并发请求，或者先尝试断掉当前请求然后再创建新的请求。  \n>2.TCP和HTTP规范中都有连接超时一说，所以所谓的长连接并不能一直持续，服务端和客户端的连接需要定期的连接和关闭再连接，当然也有一些技术能够延长每次连接的时间，这是题外话。  \n\n## Applet和Flash\nApplet和Flash都已经是明日黄花了，不过这两个技术在当年除了可以让我们的HTML页面更加绚丽之外，还可以解决消息推送问题。在Ajax这种技术去实现全双工通信已经陷入困境的时候，开发者试图用Applet和Flash来模拟全双工通信，开发者可以创建一个只有1个像素点大小的普通透明的Applet或者Flash，然后将之内嵌在页面中， 然后这个Applet或者Flash中的代码创建出一个Socket连接，这种连接方式消除了HTTP协议中的各种限制，当服务器有消息发送到客户端的时候，开发者可以在Applet或者Flash中调用JavaScript函数，并将服务器传来的消息传递给JavaScript函数，然后更新页面，当浏览器有数据要发送给服务器的时候，也一样，通过Applet或者Flash来传递。这种方式真正的实现了全双工通信，不过也有问题，如下：\n>1.浏览器必须能够运行Java或者Flash  \n>2.无论是Applet还是Flash都存在安全问题  \n>3.随着HTML5在标准在浏览器中广泛支持，Flash下架已经被提上日程([\n终于要放弃，Adobe宣布2020年正式停止支持Flash](http://tech.163.com/17/0726/07/CQ8M4HT200097U7T.html))  \n\n# WebSocket有哪些特点\n\n既然上面这些技术都不行，那么谁行？当然是我WebSocket了！\n\n## HTTP/1.1的升级特性\n要说WebSocket协议，我们得先来说说HTTP协议的一个请求头，事实上，所有的HTTP客户端（浏览器、移动端等）都可以在请求头中包含Connection:Upgrade，这个表示客户端希望升级请求协议，那么希望升级成什么样的协议呢？我们需要在Upgrade头中指定一个或者多个协议的列表，当然这些协议必须兼容HTTP/1.1协议。服务器收到请求之后，如果接受升级请求，那么将会返回一个101的状态码，表示转换请求协议，同时在响应的Upgrade头中使用单个值，这个单个值就是请求协议列表中服务器支持的第一个协议（即请求头的Upgrade字段中列出来的协议列表中服务器支持的第一个协议）。  \nHTTP升级最大的好处是最终使我们可以使用任意的协议，在升级握手完成之后，它就不再使用HTTP连接了，我们甚至可以在升级握手完成之后建立一个Socket连接，理论上我们可以使用HTTP升级在两个端点之间使用任何自己设计的协议，进而创建出各种各样的TCP通信，当然浏览器不会让开发者随意去这么做，而是要指定某些协议，WebSocket应运而生！\n我们来看一个截图：  \n![这里写图片描述](http://img.blog.csdn.net/20170827204229481?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjcwMjU0Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n## 使用HTTP/1.1升级的WebSocket协议\nOK，了解了HTTP/1.1协议的升级特性之后，我们再来详细看看整个过程是怎么样的？  \n一个WebSocket请求首先使用非正常的HTTP请求以特定的模式访问一个URL，这个URL有两种模式，分别是ws和wss，对应HTTP协议中的http和https，请求头中除了Connection:Upgrade之外还有一个Upgrade:websocket,它们两个将共同告诉服务器将连接升级为WebSocket这样一种全双工协议。如此，在握手完成之后，文本消息或者其他二进制消息就可以同时在两个方向上进行发送，而不需要关闭和重建连接。此时的客户端和服务端关系其实是对等的，他们都可以互相向对方主动发消息。那么这里有一点需要注意：那就是ws和wss模式并不能算作HTTP协议的一部分，因为HTTP请求和请求头并不包含URL模式，HTTP请求只在请求的第一行中包含相对于服务器的URL，在Host头中包含域名，而WebSocket中特有的ws和wss模式主要用于通知浏览器和API是希望使用SSL/TLS(wss)，还是希望使用不加密的方式(ws)进行连接。\n## WebSocket协议的优势\n说了这么多，那么接下来我们来看看WebSocket协议都有哪些优势：\n>1.由于WebSocket连接在端口80(ws)或者443(wss)上创建，与HTTP使用的端口相同，这样，基本上所有的防火墙都不会阻塞WebSocket连接  \n\n>2.WebSocket使用HTTP协议进行握手，因此它可以自然而然的集成到网络浏览器和HTTP服务器中  \n\n>3.心跳消息(ping和pong)将被反复的发送，进而保持WebSocket连接几乎一直处于活跃状态。一般来说是这样，一个节点周期性的发送一个小数据包到另外一个节点(ping)，而另一个节点则使用了包含了相同数据的数据包作为响应(pong),这样两个节点都将处于连接状态  \n\n>4.使用该协议，当消息启动或者到达的时候，服务端和客户端都可以知道  \n\n>5.WebSocket连接关闭时将发送一个特殊的关闭消息  \n\n>6.WebSocket支持跨域，可以避免Ajax的限制  \n\n>7.HTTP规范要求浏览器将并发连接数限制为每个主机名两个连接，但是当我们使用WebSocket的时候，当握手完成之后该限制就不存在了，因为此时的连接已经不再是HTTP连接了  \n## WebSocket协议的用途\n\n说了这么多那么WebSocket协议到底可以用在哪些地方呢？事实上，WebSocket协议的用途几乎是没有限制的，比如：\n\n>1.网页上的在线聊天   \n\n>2.多人在线游戏   \n\n>3.在线股票网站   \n\n>4.在线即时新闻网站   \n\n>5.高清视频流   \n\n>6.应用集群之间的通信  \n\n>7.远程系统/软件的状态和性能的实时监控 \n\n\n# 结语  \n\n说了这么多，可能很多小伙伴觉得这个WebSocket貌似用起来很麻烦，其实不麻烦，所有的东西都有对应的API来帮助我们实现，<big>**小伙伴们稍安勿躁，我们将在下篇文章中来介绍WebSocket的实战应用。**</big>\n\n参考资料：《JavaEE 编程》\n\n更多JavaEE资料请关注公众号  \n![这里写图片描述](http://img.blog.csdn.net/20170827204306560?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjcwMjU0Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n以上。\n', '<p>年初的时候，写过两篇博客介绍在Spring Boot中如何使用WebSocket发送消息【<a href=\"http://blog.csdn.net/u012702547/article/details/53816326\" target=\"_blank\">在Spring Boot框架下使用WebSocket实现消息推送</a>】【<a href=\"http://blog.csdn.net/u012702547/article/details/53835453\" target=\"_blank\">在Spring Boot框架下使用WebSocket实现聊天功能</a>】，最近看到很多小伙伴对WebSocket的讨论还比较火热，so，打算写几篇文章来系统的介绍下websocket。OK，废话不多说，下面开始我们的正文。</p>\n<hr />\n<h1>为什么要有WebSocket这个技术</h1>\n<p>大家都知道，HTML页面在刚刚开始出现的时候是静态的，不能够进行交互，后来有了JavaScript，在一定程度上解决了这个问题，但是JavaScript刚出现的时候并不能和服务端进行交互，直到Ajax的出现。Ajax有效的解决了页面和服务端进行交互的问题，不过Ajax有一个问题，就是所有的请求都必须由客户端发起，服务端进行响应，如果服务端有最新的消息，难以即时的发送到客户端去，在WebSocket技术出现之前，为了让客户端能够即时的获取服务端的数据，一般采用如下三种方案：</p>\n<h2>轮询</h2>\n<p>这是最简单的一种解决方案， 就是客户端在固定的时间间隔下（一般是1秒）不停的向服务器端发送请求，查看服务端是否有最新的数据，服务端如果有最新的数据则返回给客户端，服务端如果没有则返回一个空的json或者xml文档，这种方式的实现起来简单，但是弊端也很明显，就是会有大量的无效请求，服务端的资源被大大的浪费了。</p>\n<h2>长连接</h2>\n<p>长连接有点类似于轮询，不同的是服务端不是每次都会响应客户端的请求，只有在服务端有最新数据的时候才会响应客户端的请求，这种方式很明显会节省网络资源和服务端资源，但是也存在一些问题，比如：</p>\n<blockquote>\n<p>1.如果浏览器在服务器响应之前有新数据要发送就只能创建一个新的并发请求，或者先尝试断掉当前请求然后再创建新的请求。<br />\n2.TCP和HTTP规范中都有连接超时一说，所以所谓的长连接并不能一直持续，服务端和客户端的连接需要定期的连接和关闭再连接，当然也有一些技术能够延长每次连接的时间，这是题外话。</p>\n</blockquote>\n<h2>Applet和Flash</h2>\n<p>Applet和Flash都已经是明日黄花了，不过这两个技术在当年除了可以让我们的HTML页面更加绚丽之外，还可以解决消息推送问题。在Ajax这种技术去实现全双工通信已经陷入困境的时候，开发者试图用Applet和Flash来模拟全双工通信，开发者可以创建一个只有1个像素点大小的普通透明的Applet或者Flash，然后将之内嵌在页面中， 然后这个Applet或者Flash中的代码创建出一个Socket连接，这种连接方式消除了HTTP协议中的各种限制，当服务器有消息发送到客户端的时候，开发者可以在Applet或者Flash中调用JavaScript函数，并将服务器传来的消息传递给JavaScript函数，然后更新页面，当浏览器有数据要发送给服务器的时候，也一样，通过Applet或者Flash来传递。这种方式真正的实现了全双工通信，不过也有问题，如下：</p>\n<blockquote>\n<p>1.浏览器必须能够运行Java或者Flash<br />\n2.无论是Applet还是Flash都存在安全问题<br />\n3.随着HTML5在标准在浏览器中广泛支持，Flash下架已经被提上日程(<a href=\"http://tech.163.com/17/0726/07/CQ8M4HT200097U7T.html\" target=\"_blank\"><br />\n终于要放弃，Adobe宣布2020年正式停止支持Flash</a>)</p>\n</blockquote>\n<h1>WebSocket有哪些特点</h1>\n<p>既然上面这些技术都不行，那么谁行？当然是我WebSocket了！</p>\n<h2>HTTP/1.1的升级特性</h2>\n<p>要说WebSocket协议，我们得先来说说HTTP协议的一个请求头，事实上，所有的HTTP客户端（浏览器、移动端等）都可以在请求头中包含Connection:Upgrade，这个表示客户端希望升级请求协议，那么希望升级成什么样的协议呢？我们需要在Upgrade头中指定一个或者多个协议的列表，当然这些协议必须兼容HTTP/1.1协议。服务器收到请求之后，如果接受升级请求，那么将会返回一个101的状态码，表示转换请求协议，同时在响应的Upgrade头中使用单个值，这个单个值就是请求协议列表中服务器支持的第一个协议（即请求头的Upgrade字段中列出来的协议列表中服务器支持的第一个协议）。<br />\nHTTP升级最大的好处是最终使我们可以使用任意的协议，在升级握手完成之后，它就不再使用HTTP连接了，我们甚至可以在升级握手完成之后建立一个Socket连接，理论上我们可以使用HTTP升级在两个端点之间使用任何自己设计的协议，进而创建出各种各样的TCP通信，当然浏览器不会让开发者随意去这么做，而是要指定某些协议，WebSocket应运而生！<br />\n我们来看一个截图：<br />\n<img src=\"http://img.blog.csdn.net/20170827204229481?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjcwMjU0Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" /></p>\n<h2>使用HTTP/1.1升级的WebSocket协议</h2>\n<p>OK，了解了HTTP/1.1协议的升级特性之后，我们再来详细看看整个过程是怎么样的？<br />\n一个WebSocket请求首先使用非正常的HTTP请求以特定的模式访问一个URL，这个URL有两种模式，分别是ws和wss，对应HTTP协议中的http和https，请求头中除了Connection:Upgrade之外还有一个Upgrade:websocket,它们两个将共同告诉服务器将连接升级为WebSocket这样一种全双工协议。如此，在握手完成之后，文本消息或者其他二进制消息就可以同时在两个方向上进行发送，而不需要关闭和重建连接。此时的客户端和服务端关系其实是对等的，他们都可以互相向对方主动发消息。那么这里有一点需要注意：那就是ws和wss模式并不能算作HTTP协议的一部分，因为HTTP请求和请求头并不包含URL模式，HTTP请求只在请求的第一行中包含相对于服务器的URL，在Host头中包含域名，而WebSocket中特有的ws和wss模式主要用于通知浏览器和API是希望使用SSL/TLS(wss)，还是希望使用不加密的方式(ws)进行连接。</p>\n<h2>WebSocket协议的优势</h2>\n<p>说了这么多，那么接下来我们来看看WebSocket协议都有哪些优势：</p>\n<blockquote>\n<p>1.由于WebSocket连接在端口80(ws)或者443(wss)上创建，与HTTP使用的端口相同，这样，基本上所有的防火墙都不会阻塞WebSocket连接</p>\n</blockquote>\n<blockquote>\n<p>2.WebSocket使用HTTP协议进行握手，因此它可以自然而然的集成到网络浏览器和HTTP服务器中</p>\n</blockquote>\n<blockquote>\n<p>3.心跳消息(ping和pong)将被反复的发送，进而保持WebSocket连接几乎一直处于活跃状态。一般来说是这样，一个节点周期性的发送一个小数据包到另外一个节点(ping)，而另一个节点则使用了包含了相同数据的数据包作为响应(pong),这样两个节点都将处于连接状态</p>\n</blockquote>\n<blockquote>\n<p>4.使用该协议，当消息启动或者到达的时候，服务端和客户端都可以知道</p>\n</blockquote>\n<blockquote>\n<p>5.WebSocket连接关闭时将发送一个特殊的关闭消息</p>\n</blockquote>\n<blockquote>\n<p>6.WebSocket支持跨域，可以避免Ajax的限制</p>\n</blockquote>\n<blockquote>\n<p>7.HTTP规范要求浏览器将并发连接数限制为每个主机名两个连接，但是当我们使用WebSocket的时候，当握手完成之后该限制就不存在了，因为此时的连接已经不再是HTTP连接了</p>\n</blockquote>\n<h2>WebSocket协议的用途</h2>\n<p>说了这么多那么WebSocket协议到底可以用在哪些地方呢？事实上，WebSocket协议的用途几乎是没有限制的，比如：</p>\n<blockquote>\n<p>1.网页上的在线聊天</p>\n</blockquote>\n<blockquote>\n<p>2.多人在线游戏</p>\n</blockquote>\n<blockquote>\n<p>3.在线股票网站</p>\n</blockquote>\n<blockquote>\n<p>4.在线即时新闻网站</p>\n</blockquote>\n<blockquote>\n<p>5.高清视频流</p>\n</blockquote>\n<blockquote>\n<p>6.应用集群之间的通信</p>\n</blockquote>\n<blockquote>\n<p>7.远程系统/软件的状态和性能的实时监控</p>\n</blockquote>\n<h1>结语</h1>\n<p>说了这么多，可能很多小伙伴觉得这个WebSocket貌似用起来很麻烦，其实不麻烦，所有的东西都有对应的API来帮助我们实现，<big><strong>小伙伴们稍安勿躁，我们将在下篇文章中来介绍WebSocket的实战应用。</strong></big></p>\n<p>参考资料：《JavaEE 编程》</p>\n<p>更多JavaEE资料请关注公众号<br />\n<img src=\"http://img.blog.csdn.net/20170827204306560?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjcwMjU0Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" /></p>\n<p>以上。</p>\n', '对应移动在此小区的策略，我们这样应对。。','1','arpu值提高1',4,'1');
INSERT INTO `strategy` VALUES ('2', '应对竞争信息2','年初的时候，写过两篇博客介绍在Spring Boot中如何使用WebSocket发送消息【[在Spring Boot框架下使用WebSocket实现消息推送](http://blog.csdn.net/u012702547/article/details/53816326)】【[在Spring Boot框架下使用WebSocket实现聊天功能](http://blog.csdn.net/u012702547/article/details/53835453)】，最近看到很多小伙伴对WebSocket的讨论还比较火热，so，打算写几篇文章来系统的介绍下websocket。OK，废话不多说，下面开始我们的正文。\n\n---\n# 为什么要有WebSocket这个技术\n\n大家都知道，HTML页面在刚刚开始出现的时候是静态的，不能够进行交互，后来有了JavaScript，在一定程度上解决了这个问题，但是JavaScript刚出现的时候并不能和服务端进行交互，直到Ajax的出现。Ajax有效的解决了页面和服务端进行交互的问题，不过Ajax有一个问题，就是所有的请求都必须由客户端发起，服务端进行响应，如果服务端有最新的消息，难以即时的发送到客户端去，在WebSocket技术出现之前，为了让客户端能够即时的获取服务端的数据，一般采用如下三种方案：\n## 轮询\n这是最简单的一种解决方案， 就是客户端在固定的时间间隔下（一般是1秒）不停的向服务器端发送请求，查看服务端是否有最新的数据，服务端如果有最新的数据则返回给客户端，服务端如果没有则返回一个空的json或者xml文档，这种方式的实现起来简单，但是弊端也很明显，就是会有大量的无效请求，服务端的资源被大大的浪费了。\n## 长连接\n长连接有点类似于轮询，不同的是服务端不是每次都会响应客户端的请求，只有在服务端有最新数据的时候才会响应客户端的请求，这种方式很明显会节省网络资源和服务端资源，但是也存在一些问题，比如：\n>1.如果浏览器在服务器响应之前有新数据要发送就只能创建一个新的并发请求，或者先尝试断掉当前请求然后再创建新的请求。  \n>2.TCP和HTTP规范中都有连接超时一说，所以所谓的长连接并不能一直持续，服务端和客户端的连接需要定期的连接和关闭再连接，当然也有一些技术能够延长每次连接的时间，这是题外话。  \n\n## Applet和Flash\nApplet和Flash都已经是明日黄花了，不过这两个技术在当年除了可以让我们的HTML页面更加绚丽之外，还可以解决消息推送问题。在Ajax这种技术去实现全双工通信已经陷入困境的时候，开发者试图用Applet和Flash来模拟全双工通信，开发者可以创建一个只有1个像素点大小的普通透明的Applet或者Flash，然后将之内嵌在页面中， 然后这个Applet或者Flash中的代码创建出一个Socket连接，这种连接方式消除了HTTP协议中的各种限制，当服务器有消息发送到客户端的时候，开发者可以在Applet或者Flash中调用JavaScript函数，并将服务器传来的消息传递给JavaScript函数，然后更新页面，当浏览器有数据要发送给服务器的时候，也一样，通过Applet或者Flash来传递。这种方式真正的实现了全双工通信，不过也有问题，如下：\n>1.浏览器必须能够运行Java或者Flash  \n>2.无论是Applet还是Flash都存在安全问题  \n>3.随着HTML5在标准在浏览器中广泛支持，Flash下架已经被提上日程([\n终于要放弃，Adobe宣布2020年正式停止支持Flash](http://tech.163.com/17/0726/07/CQ8M4HT200097U7T.html))  \n\n# WebSocket有哪些特点\n\n既然上面这些技术都不行，那么谁行？当然是我WebSocket了！\n\n## HTTP/1.1的升级特性\n要说WebSocket协议，我们得先来说说HTTP协议的一个请求头，事实上，所有的HTTP客户端（浏览器、移动端等）都可以在请求头中包含Connection:Upgrade，这个表示客户端希望升级请求协议，那么希望升级成什么样的协议呢？我们需要在Upgrade头中指定一个或者多个协议的列表，当然这些协议必须兼容HTTP/1.1协议。服务器收到请求之后，如果接受升级请求，那么将会返回一个101的状态码，表示转换请求协议，同时在响应的Upgrade头中使用单个值，这个单个值就是请求协议列表中服务器支持的第一个协议（即请求头的Upgrade字段中列出来的协议列表中服务器支持的第一个协议）。  \nHTTP升级最大的好处是最终使我们可以使用任意的协议，在升级握手完成之后，它就不再使用HTTP连接了，我们甚至可以在升级握手完成之后建立一个Socket连接，理论上我们可以使用HTTP升级在两个端点之间使用任何自己设计的协议，进而创建出各种各样的TCP通信，当然浏览器不会让开发者随意去这么做，而是要指定某些协议，WebSocket应运而生！\n我们来看一个截图：  \n![这里写图片描述](http://img.blog.csdn.net/20170827204229481?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjcwMjU0Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n## 使用HTTP/1.1升级的WebSocket协议\nOK，了解了HTTP/1.1协议的升级特性之后，我们再来详细看看整个过程是怎么样的？  \n一个WebSocket请求首先使用非正常的HTTP请求以特定的模式访问一个URL，这个URL有两种模式，分别是ws和wss，对应HTTP协议中的http和https，请求头中除了Connection:Upgrade之外还有一个Upgrade:websocket,它们两个将共同告诉服务器将连接升级为WebSocket这样一种全双工协议。如此，在握手完成之后，文本消息或者其他二进制消息就可以同时在两个方向上进行发送，而不需要关闭和重建连接。此时的客户端和服务端关系其实是对等的，他们都可以互相向对方主动发消息。那么这里有一点需要注意：那就是ws和wss模式并不能算作HTTP协议的一部分，因为HTTP请求和请求头并不包含URL模式，HTTP请求只在请求的第一行中包含相对于服务器的URL，在Host头中包含域名，而WebSocket中特有的ws和wss模式主要用于通知浏览器和API是希望使用SSL/TLS(wss)，还是希望使用不加密的方式(ws)进行连接。\n## WebSocket协议的优势\n说了这么多，那么接下来我们来看看WebSocket协议都有哪些优势：\n>1.由于WebSocket连接在端口80(ws)或者443(wss)上创建，与HTTP使用的端口相同，这样，基本上所有的防火墙都不会阻塞WebSocket连接  \n\n>2.WebSocket使用HTTP协议进行握手，因此它可以自然而然的集成到网络浏览器和HTTP服务器中  \n\n>3.心跳消息(ping和pong)将被反复的发送，进而保持WebSocket连接几乎一直处于活跃状态。一般来说是这样，一个节点周期性的发送一个小数据包到另外一个节点(ping)，而另一个节点则使用了包含了相同数据的数据包作为响应(pong),这样两个节点都将处于连接状态  \n\n>4.使用该协议，当消息启动或者到达的时候，服务端和客户端都可以知道  \n\n>5.WebSocket连接关闭时将发送一个特殊的关闭消息  \n\n>6.WebSocket支持跨域，可以避免Ajax的限制  \n\n>7.HTTP规范要求浏览器将并发连接数限制为每个主机名两个连接，但是当我们使用WebSocket的时候，当握手完成之后该限制就不存在了，因为此时的连接已经不再是HTTP连接了  \n## WebSocket协议的用途\n\n说了这么多那么WebSocket协议到底可以用在哪些地方呢？事实上，WebSocket协议的用途几乎是没有限制的，比如：\n\n>1.网页上的在线聊天   \n\n>2.多人在线游戏   \n\n>3.在线股票网站   \n\n>4.在线即时新闻网站   \n\n>5.高清视频流   \n\n>6.应用集群之间的通信  \n\n>7.远程系统/软件的状态和性能的实时监控 \n\n\n# 结语  \n\n说了这么多，可能很多小伙伴觉得这个WebSocket貌似用起来很麻烦，其实不麻烦，所有的东西都有对应的API来帮助我们实现，<big>**小伙伴们稍安勿躁，我们将在下篇文章中来介绍WebSocket的实战应用。**</big>\n\n参考资料：《JavaEE 编程》\n\n更多JavaEE资料请关注公众号  \n![这里写图片描述](http://img.blog.csdn.net/20170827204306560?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjcwMjU0Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n以上。\n', '<p>年初的时候，写过两篇博客介绍在Spring Boot中如何使用WebSocket发送消息【<a href=\"http://blog.csdn.net/u012702547/article/details/53816326\" target=\"_blank\">在Spring Boot框架下使用WebSocket实现消息推送</a>】【<a href=\"http://blog.csdn.net/u012702547/article/details/53835453\" target=\"_blank\">在Spring Boot框架下使用WebSocket实现聊天功能</a>】，最近看到很多小伙伴对WebSocket的讨论还比较火热，so，打算写几篇文章来系统的介绍下websocket。OK，废话不多说，下面开始我们的正文。</p>\n<hr />\n<h1>为什么要有WebSocket这个技术</h1>\n<p>大家都知道，HTML页面在刚刚开始出现的时候是静态的，不能够进行交互，后来有了JavaScript，在一定程度上解决了这个问题，但是JavaScript刚出现的时候并不能和服务端进行交互，直到Ajax的出现。Ajax有效的解决了页面和服务端进行交互的问题，不过Ajax有一个问题，就是所有的请求都必须由客户端发起，服务端进行响应，如果服务端有最新的消息，难以即时的发送到客户端去，在WebSocket技术出现之前，为了让客户端能够即时的获取服务端的数据，一般采用如下三种方案：</p>\n<h2>轮询</h2>\n<p>这是最简单的一种解决方案， 就是客户端在固定的时间间隔下（一般是1秒）不停的向服务器端发送请求，查看服务端是否有最新的数据，服务端如果有最新的数据则返回给客户端，服务端如果没有则返回一个空的json或者xml文档，这种方式的实现起来简单，但是弊端也很明显，就是会有大量的无效请求，服务端的资源被大大的浪费了。</p>\n<h2>长连接</h2>\n<p>长连接有点类似于轮询，不同的是服务端不是每次都会响应客户端的请求，只有在服务端有最新数据的时候才会响应客户端的请求，这种方式很明显会节省网络资源和服务端资源，但是也存在一些问题，比如：</p>\n<blockquote>\n<p>1.如果浏览器在服务器响应之前有新数据要发送就只能创建一个新的并发请求，或者先尝试断掉当前请求然后再创建新的请求。<br />\n2.TCP和HTTP规范中都有连接超时一说，所以所谓的长连接并不能一直持续，服务端和客户端的连接需要定期的连接和关闭再连接，当然也有一些技术能够延长每次连接的时间，这是题外话。</p>\n</blockquote>\n<h2>Applet和Flash</h2>\n<p>Applet和Flash都已经是明日黄花了，不过这两个技术在当年除了可以让我们的HTML页面更加绚丽之外，还可以解决消息推送问题。在Ajax这种技术去实现全双工通信已经陷入困境的时候，开发者试图用Applet和Flash来模拟全双工通信，开发者可以创建一个只有1个像素点大小的普通透明的Applet或者Flash，然后将之内嵌在页面中， 然后这个Applet或者Flash中的代码创建出一个Socket连接，这种连接方式消除了HTTP协议中的各种限制，当服务器有消息发送到客户端的时候，开发者可以在Applet或者Flash中调用JavaScript函数，并将服务器传来的消息传递给JavaScript函数，然后更新页面，当浏览器有数据要发送给服务器的时候，也一样，通过Applet或者Flash来传递。这种方式真正的实现了全双工通信，不过也有问题，如下：</p>\n<blockquote>\n<p>1.浏览器必须能够运行Java或者Flash<br />\n2.无论是Applet还是Flash都存在安全问题<br />\n3.随着HTML5在标准在浏览器中广泛支持，Flash下架已经被提上日程(<a href=\"http://tech.163.com/17/0726/07/CQ8M4HT200097U7T.html\" target=\"_blank\"><br />\n终于要放弃，Adobe宣布2020年正式停止支持Flash</a>)</p>\n</blockquote>\n<h1>WebSocket有哪些特点</h1>\n<p>既然上面这些技术都不行，那么谁行？当然是我WebSocket了！</p>\n<h2>HTTP/1.1的升级特性</h2>\n<p>要说WebSocket协议，我们得先来说说HTTP协议的一个请求头，事实上，所有的HTTP客户端（浏览器、移动端等）都可以在请求头中包含Connection:Upgrade，这个表示客户端希望升级请求协议，那么希望升级成什么样的协议呢？我们需要在Upgrade头中指定一个或者多个协议的列表，当然这些协议必须兼容HTTP/1.1协议。服务器收到请求之后，如果接受升级请求，那么将会返回一个101的状态码，表示转换请求协议，同时在响应的Upgrade头中使用单个值，这个单个值就是请求协议列表中服务器支持的第一个协议（即请求头的Upgrade字段中列出来的协议列表中服务器支持的第一个协议）。<br />\nHTTP升级最大的好处是最终使我们可以使用任意的协议，在升级握手完成之后，它就不再使用HTTP连接了，我们甚至可以在升级握手完成之后建立一个Socket连接，理论上我们可以使用HTTP升级在两个端点之间使用任何自己设计的协议，进而创建出各种各样的TCP通信，当然浏览器不会让开发者随意去这么做，而是要指定某些协议，WebSocket应运而生！<br />\n我们来看一个截图：<br />\n<img src=\"http://img.blog.csdn.net/20170827204229481?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjcwMjU0Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" /></p>\n<h2>使用HTTP/1.1升级的WebSocket协议</h2>\n<p>OK，了解了HTTP/1.1协议的升级特性之后，我们再来详细看看整个过程是怎么样的？<br />\n一个WebSocket请求首先使用非正常的HTTP请求以特定的模式访问一个URL，这个URL有两种模式，分别是ws和wss，对应HTTP协议中的http和https，请求头中除了Connection:Upgrade之外还有一个Upgrade:websocket,它们两个将共同告诉服务器将连接升级为WebSocket这样一种全双工协议。如此，在握手完成之后，文本消息或者其他二进制消息就可以同时在两个方向上进行发送，而不需要关闭和重建连接。此时的客户端和服务端关系其实是对等的，他们都可以互相向对方主动发消息。那么这里有一点需要注意：那就是ws和wss模式并不能算作HTTP协议的一部分，因为HTTP请求和请求头并不包含URL模式，HTTP请求只在请求的第一行中包含相对于服务器的URL，在Host头中包含域名，而WebSocket中特有的ws和wss模式主要用于通知浏览器和API是希望使用SSL/TLS(wss)，还是希望使用不加密的方式(ws)进行连接。</p>\n<h2>WebSocket协议的优势</h2>\n<p>说了这么多，那么接下来我们来看看WebSocket协议都有哪些优势：</p>\n<blockquote>\n<p>1.由于WebSocket连接在端口80(ws)或者443(wss)上创建，与HTTP使用的端口相同，这样，基本上所有的防火墙都不会阻塞WebSocket连接</p>\n</blockquote>\n<blockquote>\n<p>2.WebSocket使用HTTP协议进行握手，因此它可以自然而然的集成到网络浏览器和HTTP服务器中</p>\n</blockquote>\n<blockquote>\n<p>3.心跳消息(ping和pong)将被反复的发送，进而保持WebSocket连接几乎一直处于活跃状态。一般来说是这样，一个节点周期性的发送一个小数据包到另外一个节点(ping)，而另一个节点则使用了包含了相同数据的数据包作为响应(pong),这样两个节点都将处于连接状态</p>\n</blockquote>\n<blockquote>\n<p>4.使用该协议，当消息启动或者到达的时候，服务端和客户端都可以知道</p>\n</blockquote>\n<blockquote>\n<p>5.WebSocket连接关闭时将发送一个特殊的关闭消息</p>\n</blockquote>\n<blockquote>\n<p>6.WebSocket支持跨域，可以避免Ajax的限制</p>\n</blockquote>\n<blockquote>\n<p>7.HTTP规范要求浏览器将并发连接数限制为每个主机名两个连接，但是当我们使用WebSocket的时候，当握手完成之后该限制就不存在了，因为此时的连接已经不再是HTTP连接了</p>\n</blockquote>\n<h2>WebSocket协议的用途</h2>\n<p>说了这么多那么WebSocket协议到底可以用在哪些地方呢？事实上，WebSocket协议的用途几乎是没有限制的，比如：</p>\n<blockquote>\n<p>1.网页上的在线聊天</p>\n</blockquote>\n<blockquote>\n<p>2.多人在线游戏</p>\n</blockquote>\n<blockquote>\n<p>3.在线股票网站</p>\n</blockquote>\n<blockquote>\n<p>4.在线即时新闻网站</p>\n</blockquote>\n<blockquote>\n<p>5.高清视频流</p>\n</blockquote>\n<blockquote>\n<p>6.应用集群之间的通信</p>\n</blockquote>\n<blockquote>\n<p>7.远程系统/软件的状态和性能的实时监控</p>\n</blockquote>\n<h1>结语</h1>\n<p>说了这么多，可能很多小伙伴觉得这个WebSocket貌似用起来很麻烦，其实不麻烦，所有的东西都有对应的API来帮助我们实现，<big><strong>小伙伴们稍安勿躁，我们将在下篇文章中来介绍WebSocket的实战应用。</strong></big></p>\n<p>参考资料：《JavaEE 编程》</p>\n<p>更多JavaEE资料请关注公众号<br />\n<img src=\"http://img.blog.csdn.net/20170827204306560?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjcwMjU0Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" /></p>\n<p>以上。</p>\n', '对应联通在此小区的策略，我们这样应对。。','1','arpu值降低1',8,'2');
INSERT INTO `strategy` VALUES ('3', '应对竞争信息3','年初的时候，写过两篇博客介绍在Spring Boot中如何使用WebSocket发送消息【[在Spring Boot框架下使用WebSocket实现消息推送](http://blog.csdn.net/u012702547/article/details/53816326)】【[在Spring Boot框架下使用WebSocket实现聊天功能](http://blog.csdn.net/u012702547/article/details/53835453)】，最近看到很多小伙伴对WebSocket的讨论还比较火热，so，打算写几篇文章来系统的介绍下websocket。OK，废话不多说，下面开始我们的正文。\n\n---\n# 为什么要有WebSocket这个技术\n\n大家都知道，HTML页面在刚刚开始出现的时候是静态的，不能够进行交互，后来有了JavaScript，在一定程度上解决了这个问题，但是JavaScript刚出现的时候并不能和服务端进行交互，直到Ajax的出现。Ajax有效的解决了页面和服务端进行交互的问题，不过Ajax有一个问题，就是所有的请求都必须由客户端发起，服务端进行响应，如果服务端有最新的消息，难以即时的发送到客户端去，在WebSocket技术出现之前，为了让客户端能够即时的获取服务端的数据，一般采用如下三种方案：\n## 轮询\n这是最简单的一种解决方案， 就是客户端在固定的时间间隔下（一般是1秒）不停的向服务器端发送请求，查看服务端是否有最新的数据，服务端如果有最新的数据则返回给客户端，服务端如果没有则返回一个空的json或者xml文档，这种方式的实现起来简单，但是弊端也很明显，就是会有大量的无效请求，服务端的资源被大大的浪费了。\n## 长连接\n长连接有点类似于轮询，不同的是服务端不是每次都会响应客户端的请求，只有在服务端有最新数据的时候才会响应客户端的请求，这种方式很明显会节省网络资源和服务端资源，但是也存在一些问题，比如：\n>1.如果浏览器在服务器响应之前有新数据要发送就只能创建一个新的并发请求，或者先尝试断掉当前请求然后再创建新的请求。  \n>2.TCP和HTTP规范中都有连接超时一说，所以所谓的长连接并不能一直持续，服务端和客户端的连接需要定期的连接和关闭再连接，当然也有一些技术能够延长每次连接的时间，这是题外话。  \n\n## Applet和Flash\nApplet和Flash都已经是明日黄花了，不过这两个技术在当年除了可以让我们的HTML页面更加绚丽之外，还可以解决消息推送问题。在Ajax这种技术去实现全双工通信已经陷入困境的时候，开发者试图用Applet和Flash来模拟全双工通信，开发者可以创建一个只有1个像素点大小的普通透明的Applet或者Flash，然后将之内嵌在页面中， 然后这个Applet或者Flash中的代码创建出一个Socket连接，这种连接方式消除了HTTP协议中的各种限制，当服务器有消息发送到客户端的时候，开发者可以在Applet或者Flash中调用JavaScript函数，并将服务器传来的消息传递给JavaScript函数，然后更新页面，当浏览器有数据要发送给服务器的时候，也一样，通过Applet或者Flash来传递。这种方式真正的实现了全双工通信，不过也有问题，如下：\n>1.浏览器必须能够运行Java或者Flash  \n>2.无论是Applet还是Flash都存在安全问题  \n>3.随着HTML5在标准在浏览器中广泛支持，Flash下架已经被提上日程([\n终于要放弃，Adobe宣布2020年正式停止支持Flash](http://tech.163.com/17/0726/07/CQ8M4HT200097U7T.html))  \n\n# WebSocket有哪些特点\n\n既然上面这些技术都不行，那么谁行？当然是我WebSocket了！\n\n## HTTP/1.1的升级特性\n要说WebSocket协议，我们得先来说说HTTP协议的一个请求头，事实上，所有的HTTP客户端（浏览器、移动端等）都可以在请求头中包含Connection:Upgrade，这个表示客户端希望升级请求协议，那么希望升级成什么样的协议呢？我们需要在Upgrade头中指定一个或者多个协议的列表，当然这些协议必须兼容HTTP/1.1协议。服务器收到请求之后，如果接受升级请求，那么将会返回一个101的状态码，表示转换请求协议，同时在响应的Upgrade头中使用单个值，这个单个值就是请求协议列表中服务器支持的第一个协议（即请求头的Upgrade字段中列出来的协议列表中服务器支持的第一个协议）。  \nHTTP升级最大的好处是最终使我们可以使用任意的协议，在升级握手完成之后，它就不再使用HTTP连接了，我们甚至可以在升级握手完成之后建立一个Socket连接，理论上我们可以使用HTTP升级在两个端点之间使用任何自己设计的协议，进而创建出各种各样的TCP通信，当然浏览器不会让开发者随意去这么做，而是要指定某些协议，WebSocket应运而生！\n我们来看一个截图：  \n![这里写图片描述](http://img.blog.csdn.net/20170827204229481?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjcwMjU0Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n## 使用HTTP/1.1升级的WebSocket协议\nOK，了解了HTTP/1.1协议的升级特性之后，我们再来详细看看整个过程是怎么样的？  \n一个WebSocket请求首先使用非正常的HTTP请求以特定的模式访问一个URL，这个URL有两种模式，分别是ws和wss，对应HTTP协议中的http和https，请求头中除了Connection:Upgrade之外还有一个Upgrade:websocket,它们两个将共同告诉服务器将连接升级为WebSocket这样一种全双工协议。如此，在握手完成之后，文本消息或者其他二进制消息就可以同时在两个方向上进行发送，而不需要关闭和重建连接。此时的客户端和服务端关系其实是对等的，他们都可以互相向对方主动发消息。那么这里有一点需要注意：那就是ws和wss模式并不能算作HTTP协议的一部分，因为HTTP请求和请求头并不包含URL模式，HTTP请求只在请求的第一行中包含相对于服务器的URL，在Host头中包含域名，而WebSocket中特有的ws和wss模式主要用于通知浏览器和API是希望使用SSL/TLS(wss)，还是希望使用不加密的方式(ws)进行连接。\n## WebSocket协议的优势\n说了这么多，那么接下来我们来看看WebSocket协议都有哪些优势：\n>1.由于WebSocket连接在端口80(ws)或者443(wss)上创建，与HTTP使用的端口相同，这样，基本上所有的防火墙都不会阻塞WebSocket连接  \n\n>2.WebSocket使用HTTP协议进行握手，因此它可以自然而然的集成到网络浏览器和HTTP服务器中  \n\n>3.心跳消息(ping和pong)将被反复的发送，进而保持WebSocket连接几乎一直处于活跃状态。一般来说是这样，一个节点周期性的发送一个小数据包到另外一个节点(ping)，而另一个节点则使用了包含了相同数据的数据包作为响应(pong),这样两个节点都将处于连接状态  \n\n>4.使用该协议，当消息启动或者到达的时候，服务端和客户端都可以知道  \n\n>5.WebSocket连接关闭时将发送一个特殊的关闭消息  \n\n>6.WebSocket支持跨域，可以避免Ajax的限制  \n\n>7.HTTP规范要求浏览器将并发连接数限制为每个主机名两个连接，但是当我们使用WebSocket的时候，当握手完成之后该限制就不存在了，因为此时的连接已经不再是HTTP连接了  \n## WebSocket协议的用途\n\n说了这么多那么WebSocket协议到底可以用在哪些地方呢？事实上，WebSocket协议的用途几乎是没有限制的，比如：\n\n>1.网页上的在线聊天   \n\n>2.多人在线游戏   \n\n>3.在线股票网站   \n\n>4.在线即时新闻网站   \n\n>5.高清视频流   \n\n>6.应用集群之间的通信  \n\n>7.远程系统/软件的状态和性能的实时监控 \n\n\n# 结语  \n\n说了这么多，可能很多小伙伴觉得这个WebSocket貌似用起来很麻烦，其实不麻烦，所有的东西都有对应的API来帮助我们实现，<big>**小伙伴们稍安勿躁，我们将在下篇文章中来介绍WebSocket的实战应用。**</big>\n\n参考资料：《JavaEE 编程》\n\n更多JavaEE资料请关注公众号  \n![这里写图片描述](http://img.blog.csdn.net/20170827204306560?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjcwMjU0Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n以上。\n', '<p>年初的时候，写过两篇博客介绍在Spring Boot中如何使用WebSocket发送消息【<a href=\"http://blog.csdn.net/u012702547/article/details/53816326\" target=\"_blank\">在Spring Boot框架下使用WebSocket实现消息推送</a>】【<a href=\"http://blog.csdn.net/u012702547/article/details/53835453\" target=\"_blank\">在Spring Boot框架下使用WebSocket实现聊天功能</a>】，最近看到很多小伙伴对WebSocket的讨论还比较火热，so，打算写几篇文章来系统的介绍下websocket。OK，废话不多说，下面开始我们的正文。</p>\n<hr />\n<h1>为什么要有WebSocket这个技术</h1>\n<p>大家都知道，HTML页面在刚刚开始出现的时候是静态的，不能够进行交互，后来有了JavaScript，在一定程度上解决了这个问题，但是JavaScript刚出现的时候并不能和服务端进行交互，直到Ajax的出现。Ajax有效的解决了页面和服务端进行交互的问题，不过Ajax有一个问题，就是所有的请求都必须由客户端发起，服务端进行响应，如果服务端有最新的消息，难以即时的发送到客户端去，在WebSocket技术出现之前，为了让客户端能够即时的获取服务端的数据，一般采用如下三种方案：</p>\n<h2>轮询</h2>\n<p>这是最简单的一种解决方案， 就是客户端在固定的时间间隔下（一般是1秒）不停的向服务器端发送请求，查看服务端是否有最新的数据，服务端如果有最新的数据则返回给客户端，服务端如果没有则返回一个空的json或者xml文档，这种方式的实现起来简单，但是弊端也很明显，就是会有大量的无效请求，服务端的资源被大大的浪费了。</p>\n<h2>长连接</h2>\n<p>长连接有点类似于轮询，不同的是服务端不是每次都会响应客户端的请求，只有在服务端有最新数据的时候才会响应客户端的请求，这种方式很明显会节省网络资源和服务端资源，但是也存在一些问题，比如：</p>\n<blockquote>\n<p>1.如果浏览器在服务器响应之前有新数据要发送就只能创建一个新的并发请求，或者先尝试断掉当前请求然后再创建新的请求。<br />\n2.TCP和HTTP规范中都有连接超时一说，所以所谓的长连接并不能一直持续，服务端和客户端的连接需要定期的连接和关闭再连接，当然也有一些技术能够延长每次连接的时间，这是题外话。</p>\n</blockquote>\n<h2>Applet和Flash</h2>\n<p>Applet和Flash都已经是明日黄花了，不过这两个技术在当年除了可以让我们的HTML页面更加绚丽之外，还可以解决消息推送问题。在Ajax这种技术去实现全双工通信已经陷入困境的时候，开发者试图用Applet和Flash来模拟全双工通信，开发者可以创建一个只有1个像素点大小的普通透明的Applet或者Flash，然后将之内嵌在页面中， 然后这个Applet或者Flash中的代码创建出一个Socket连接，这种连接方式消除了HTTP协议中的各种限制，当服务器有消息发送到客户端的时候，开发者可以在Applet或者Flash中调用JavaScript函数，并将服务器传来的消息传递给JavaScript函数，然后更新页面，当浏览器有数据要发送给服务器的时候，也一样，通过Applet或者Flash来传递。这种方式真正的实现了全双工通信，不过也有问题，如下：</p>\n<blockquote>\n<p>1.浏览器必须能够运行Java或者Flash<br />\n2.无论是Applet还是Flash都存在安全问题<br />\n3.随着HTML5在标准在浏览器中广泛支持，Flash下架已经被提上日程(<a href=\"http://tech.163.com/17/0726/07/CQ8M4HT200097U7T.html\" target=\"_blank\"><br />\n终于要放弃，Adobe宣布2020年正式停止支持Flash</a>)</p>\n</blockquote>\n<h1>WebSocket有哪些特点</h1>\n<p>既然上面这些技术都不行，那么谁行？当然是我WebSocket了！</p>\n<h2>HTTP/1.1的升级特性</h2>\n<p>要说WebSocket协议，我们得先来说说HTTP协议的一个请求头，事实上，所有的HTTP客户端（浏览器、移动端等）都可以在请求头中包含Connection:Upgrade，这个表示客户端希望升级请求协议，那么希望升级成什么样的协议呢？我们需要在Upgrade头中指定一个或者多个协议的列表，当然这些协议必须兼容HTTP/1.1协议。服务器收到请求之后，如果接受升级请求，那么将会返回一个101的状态码，表示转换请求协议，同时在响应的Upgrade头中使用单个值，这个单个值就是请求协议列表中服务器支持的第一个协议（即请求头的Upgrade字段中列出来的协议列表中服务器支持的第一个协议）。<br />\nHTTP升级最大的好处是最终使我们可以使用任意的协议，在升级握手完成之后，它就不再使用HTTP连接了，我们甚至可以在升级握手完成之后建立一个Socket连接，理论上我们可以使用HTTP升级在两个端点之间使用任何自己设计的协议，进而创建出各种各样的TCP通信，当然浏览器不会让开发者随意去这么做，而是要指定某些协议，WebSocket应运而生！<br />\n我们来看一个截图：<br />\n<img src=\"http://img.blog.csdn.net/20170827204229481?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjcwMjU0Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" /></p>\n<h2>使用HTTP/1.1升级的WebSocket协议</h2>\n<p>OK，了解了HTTP/1.1协议的升级特性之后，我们再来详细看看整个过程是怎么样的？<br />\n一个WebSocket请求首先使用非正常的HTTP请求以特定的模式访问一个URL，这个URL有两种模式，分别是ws和wss，对应HTTP协议中的http和https，请求头中除了Connection:Upgrade之外还有一个Upgrade:websocket,它们两个将共同告诉服务器将连接升级为WebSocket这样一种全双工协议。如此，在握手完成之后，文本消息或者其他二进制消息就可以同时在两个方向上进行发送，而不需要关闭和重建连接。此时的客户端和服务端关系其实是对等的，他们都可以互相向对方主动发消息。那么这里有一点需要注意：那就是ws和wss模式并不能算作HTTP协议的一部分，因为HTTP请求和请求头并不包含URL模式，HTTP请求只在请求的第一行中包含相对于服务器的URL，在Host头中包含域名，而WebSocket中特有的ws和wss模式主要用于通知浏览器和API是希望使用SSL/TLS(wss)，还是希望使用不加密的方式(ws)进行连接。</p>\n<h2>WebSocket协议的优势</h2>\n<p>说了这么多，那么接下来我们来看看WebSocket协议都有哪些优势：</p>\n<blockquote>\n<p>1.由于WebSocket连接在端口80(ws)或者443(wss)上创建，与HTTP使用的端口相同，这样，基本上所有的防火墙都不会阻塞WebSocket连接</p>\n</blockquote>\n<blockquote>\n<p>2.WebSocket使用HTTP协议进行握手，因此它可以自然而然的集成到网络浏览器和HTTP服务器中</p>\n</blockquote>\n<blockquote>\n<p>3.心跳消息(ping和pong)将被反复的发送，进而保持WebSocket连接几乎一直处于活跃状态。一般来说是这样，一个节点周期性的发送一个小数据包到另外一个节点(ping)，而另一个节点则使用了包含了相同数据的数据包作为响应(pong),这样两个节点都将处于连接状态</p>\n</blockquote>\n<blockquote>\n<p>4.使用该协议，当消息启动或者到达的时候，服务端和客户端都可以知道</p>\n</blockquote>\n<blockquote>\n<p>5.WebSocket连接关闭时将发送一个特殊的关闭消息</p>\n</blockquote>\n<blockquote>\n<p>6.WebSocket支持跨域，可以避免Ajax的限制</p>\n</blockquote>\n<blockquote>\n<p>7.HTTP规范要求浏览器将并发连接数限制为每个主机名两个连接，但是当我们使用WebSocket的时候，当握手完成之后该限制就不存在了，因为此时的连接已经不再是HTTP连接了</p>\n</blockquote>\n<h2>WebSocket协议的用途</h2>\n<p>说了这么多那么WebSocket协议到底可以用在哪些地方呢？事实上，WebSocket协议的用途几乎是没有限制的，比如：</p>\n<blockquote>\n<p>1.网页上的在线聊天</p>\n</blockquote>\n<blockquote>\n<p>2.多人在线游戏</p>\n</blockquote>\n<blockquote>\n<p>3.在线股票网站</p>\n</blockquote>\n<blockquote>\n<p>4.在线即时新闻网站</p>\n</blockquote>\n<blockquote>\n<p>5.高清视频流</p>\n</blockquote>\n<blockquote>\n<p>6.应用集群之间的通信</p>\n</blockquote>\n<blockquote>\n<p>7.远程系统/软件的状态和性能的实时监控</p>\n</blockquote>\n<h1>结语</h1>\n<p>说了这么多，可能很多小伙伴觉得这个WebSocket貌似用起来很麻烦，其实不麻烦，所有的东西都有对应的API来帮助我们实现，<big><strong>小伙伴们稍安勿躁，我们将在下篇文章中来介绍WebSocket的实战应用。</strong></big></p>\n<p>参考资料：《JavaEE 编程》</p>\n<p>更多JavaEE资料请关注公众号<br />\n<img src=\"http://img.blog.csdn.net/20170827204306560?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjcwMjU0Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" /></p>\n<p>以上。</p>\n', '对应移动针对此产品的策略，我们。。','1','arpu值提高1.1',8,'3');

-- ----------------------------
-- Table structure for pv
-- ----------------------------
DROP TABLE IF EXISTS `pv`;
CREATE TABLE `pv` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `countDate` date DEFAULT NULL,
  `pv` int(11) DEFAULT NULL,
  `uid` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `pv_ibfk_1` (`uid`),
  CONSTRAINT `pv_ibfk_1` FOREIGN KEY (`uid`) REFERENCES `user` (`id`) ON DELETE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=28 DEFAULT CHARSET=utf8;
-- ----------------------------
-- Records of pv
-- ----------------------------
INSERT INTO `pv` VALUES ('1', '2017-12-24', '20', '6');
INSERT INTO `pv` VALUES ('2', '2017-12-24', '14', '7');
INSERT INTO `pv` VALUES ('4', '2017-12-25', '40', '6');
INSERT INTO `pv` VALUES ('5', '2017-12-25', '23', '7');
INSERT INTO `pv` VALUES ('6', '2017-12-26', '11', '6');
INSERT INTO `pv` VALUES ('7', '2017-12-26', '32', '7');
INSERT INTO `pv` VALUES ('26', '2017-12-23', '2', '6');
INSERT INTO `pv` VALUES ('27', '2017-12-23', '77', '7');

